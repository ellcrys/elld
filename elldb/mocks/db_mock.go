package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/ellcrys/elld/elldb.DB -o ./mocks/db_mock.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_elldb "github.com/ellcrys/elld/elldb"
	"github.com/gojuno/minimock"
)

// DBMock implements elldb.DB
type DBMock struct {
	t minimock.Tester

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mDBMockClose

	funcDeleteByPrefix          func(ba1 []byte) (err error)
	inspectFuncDeleteByPrefix   func(ba1 []byte)
	afterDeleteByPrefixCounter  uint64
	beforeDeleteByPrefixCounter uint64
	DeleteByPrefixMock          mDBMockDeleteByPrefix

	funcGetByPrefix          func(ba1 []byte) (result []*mm_elldb.KVObject)
	inspectFuncGetByPrefix   func(ba1 []byte)
	afterGetByPrefixCounter  uint64
	beforeGetByPrefixCounter uint64
	GetByPrefixMock          mDBMockGetByPrefix

	funcGetFirstOrLast          func(prefix []byte, first bool) (kp1 *mm_elldb.KVObject)
	inspectFuncGetFirstOrLast   func(prefix []byte, first bool)
	afterGetFirstOrLastCounter  uint64
	beforeGetFirstOrLastCounter uint64
	GetFirstOrLastMock          mDBMockGetFirstOrLast

	funcIterate          func(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool) (err error)
	inspectFuncIterate   func(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool)
	afterIterateCounter  uint64
	beforeIterateCounter uint64
	IterateMock          mDBMockIterate

	funcNewTx          func() (t1 mm_elldb.Tx, err error)
	inspectFuncNewTx   func()
	afterNewTxCounter  uint64
	beforeNewTxCounter uint64
	NewTxMock          mDBMockNewTx

	funcOpen          func(namespace string) (err error)
	inspectFuncOpen   func(namespace string)
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mDBMockOpen

	funcPut          func(kpa1 []*mm_elldb.KVObject) (err error)
	inspectFuncPut   func(kpa1 []*mm_elldb.KVObject)
	afterPutCounter  uint64
	beforePutCounter uint64
	PutMock          mDBMockPut

	funcTruncate          func() (err error)
	inspectFuncTruncate   func()
	afterTruncateCounter  uint64
	beforeTruncateCounter uint64
	TruncateMock          mDBMockTruncate

	funcTruncateWithFunc          func(prefix []byte, first bool, predicate func(kv *mm_elldb.KVObject) bool) (err error)
	inspectFuncTruncateWithFunc   func(prefix []byte, first bool, predicate func(kv *mm_elldb.KVObject) bool)
	afterTruncateWithFuncCounter  uint64
	beforeTruncateWithFuncCounter uint64
	TruncateWithFuncMock          mDBMockTruncateWithFunc
}

// NewDBMock returns a mock for elldb.DB
func NewDBMock(t minimock.Tester) *DBMock {
	m := &DBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mDBMockClose{mock: m}

	m.DeleteByPrefixMock = mDBMockDeleteByPrefix{mock: m}
	m.DeleteByPrefixMock.callArgs = []*DBMockDeleteByPrefixParams{}

	m.GetByPrefixMock = mDBMockGetByPrefix{mock: m}
	m.GetByPrefixMock.callArgs = []*DBMockGetByPrefixParams{}

	m.GetFirstOrLastMock = mDBMockGetFirstOrLast{mock: m}
	m.GetFirstOrLastMock.callArgs = []*DBMockGetFirstOrLastParams{}

	m.IterateMock = mDBMockIterate{mock: m}
	m.IterateMock.callArgs = []*DBMockIterateParams{}

	m.NewTxMock = mDBMockNewTx{mock: m}

	m.OpenMock = mDBMockOpen{mock: m}
	m.OpenMock.callArgs = []*DBMockOpenParams{}

	m.PutMock = mDBMockPut{mock: m}
	m.PutMock.callArgs = []*DBMockPutParams{}

	m.TruncateMock = mDBMockTruncate{mock: m}

	m.TruncateWithFuncMock = mDBMockTruncateWithFunc{mock: m}
	m.TruncateWithFuncMock.callArgs = []*DBMockTruncateWithFuncParams{}

	return m
}

type mDBMockClose struct {
	mock               *DBMock
	defaultExpectation *DBMockCloseExpectation
	expectations       []*DBMockCloseExpectation
}

// DBMockCloseExpectation specifies expectation struct of the DB.Close
type DBMockCloseExpectation struct {
	mock *DBMock

	results *DBMockCloseResults
	Counter uint64
}

// DBMockCloseResults contains results of the DB.Close
type DBMockCloseResults struct {
	err error
}

// Expect sets up expected params for DB.Close
func (mmClose *mDBMockClose) Expect() *mDBMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("DBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &DBMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the DB.Close
func (mmClose *mDBMockClose) Inspect(f func()) *mDBMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for DBMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by DB.Close
func (mmClose *mDBMockClose) Return(err error) *DBMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("DBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &DBMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &DBMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the DB.Close method
func (mmClose *mDBMockClose) Set(f func() (err error)) *DBMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the DB.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the DB.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements elldb.DB
func (mmClose *DBMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the DBMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to DBMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished DBMock.Close invocations
func (mmClose *DBMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of DBMock.Close invocations
func (mmClose *DBMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *DBMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DBMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to DBMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to DBMock.Close")
	}
}

type mDBMockDeleteByPrefix struct {
	mock               *DBMock
	defaultExpectation *DBMockDeleteByPrefixExpectation
	expectations       []*DBMockDeleteByPrefixExpectation

	callArgs []*DBMockDeleteByPrefixParams
	mutex    sync.RWMutex
}

// DBMockDeleteByPrefixExpectation specifies expectation struct of the DB.DeleteByPrefix
type DBMockDeleteByPrefixExpectation struct {
	mock    *DBMock
	params  *DBMockDeleteByPrefixParams
	results *DBMockDeleteByPrefixResults
	Counter uint64
}

// DBMockDeleteByPrefixParams contains parameters of the DB.DeleteByPrefix
type DBMockDeleteByPrefixParams struct {
	ba1 []byte
}

// DBMockDeleteByPrefixResults contains results of the DB.DeleteByPrefix
type DBMockDeleteByPrefixResults struct {
	err error
}

// Expect sets up expected params for DB.DeleteByPrefix
func (mmDeleteByPrefix *mDBMockDeleteByPrefix) Expect(ba1 []byte) *mDBMockDeleteByPrefix {
	if mmDeleteByPrefix.mock.funcDeleteByPrefix != nil {
		mmDeleteByPrefix.mock.t.Fatalf("DBMock.DeleteByPrefix mock is already set by Set")
	}

	if mmDeleteByPrefix.defaultExpectation == nil {
		mmDeleteByPrefix.defaultExpectation = &DBMockDeleteByPrefixExpectation{}
	}

	mmDeleteByPrefix.defaultExpectation.params = &DBMockDeleteByPrefixParams{ba1}
	for _, e := range mmDeleteByPrefix.expectations {
		if minimock.Equal(e.params, mmDeleteByPrefix.defaultExpectation.params) {
			mmDeleteByPrefix.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteByPrefix.defaultExpectation.params)
		}
	}

	return mmDeleteByPrefix
}

// Inspect accepts an inspector function that has same arguments as the DB.DeleteByPrefix
func (mmDeleteByPrefix *mDBMockDeleteByPrefix) Inspect(f func(ba1 []byte)) *mDBMockDeleteByPrefix {
	if mmDeleteByPrefix.mock.inspectFuncDeleteByPrefix != nil {
		mmDeleteByPrefix.mock.t.Fatalf("Inspect function is already set for DBMock.DeleteByPrefix")
	}

	mmDeleteByPrefix.mock.inspectFuncDeleteByPrefix = f

	return mmDeleteByPrefix
}

// Return sets up results that will be returned by DB.DeleteByPrefix
func (mmDeleteByPrefix *mDBMockDeleteByPrefix) Return(err error) *DBMock {
	if mmDeleteByPrefix.mock.funcDeleteByPrefix != nil {
		mmDeleteByPrefix.mock.t.Fatalf("DBMock.DeleteByPrefix mock is already set by Set")
	}

	if mmDeleteByPrefix.defaultExpectation == nil {
		mmDeleteByPrefix.defaultExpectation = &DBMockDeleteByPrefixExpectation{mock: mmDeleteByPrefix.mock}
	}
	mmDeleteByPrefix.defaultExpectation.results = &DBMockDeleteByPrefixResults{err}
	return mmDeleteByPrefix.mock
}

//Set uses given function f to mock the DB.DeleteByPrefix method
func (mmDeleteByPrefix *mDBMockDeleteByPrefix) Set(f func(ba1 []byte) (err error)) *DBMock {
	if mmDeleteByPrefix.defaultExpectation != nil {
		mmDeleteByPrefix.mock.t.Fatalf("Default expectation is already set for the DB.DeleteByPrefix method")
	}

	if len(mmDeleteByPrefix.expectations) > 0 {
		mmDeleteByPrefix.mock.t.Fatalf("Some expectations are already set for the DB.DeleteByPrefix method")
	}

	mmDeleteByPrefix.mock.funcDeleteByPrefix = f
	return mmDeleteByPrefix.mock
}

// When sets expectation for the DB.DeleteByPrefix which will trigger the result defined by the following
// Then helper
func (mmDeleteByPrefix *mDBMockDeleteByPrefix) When(ba1 []byte) *DBMockDeleteByPrefixExpectation {
	if mmDeleteByPrefix.mock.funcDeleteByPrefix != nil {
		mmDeleteByPrefix.mock.t.Fatalf("DBMock.DeleteByPrefix mock is already set by Set")
	}

	expectation := &DBMockDeleteByPrefixExpectation{
		mock:   mmDeleteByPrefix.mock,
		params: &DBMockDeleteByPrefixParams{ba1},
	}
	mmDeleteByPrefix.expectations = append(mmDeleteByPrefix.expectations, expectation)
	return expectation
}

// Then sets up DB.DeleteByPrefix return parameters for the expectation previously defined by the When method
func (e *DBMockDeleteByPrefixExpectation) Then(err error) *DBMock {
	e.results = &DBMockDeleteByPrefixResults{err}
	return e.mock
}

// DeleteByPrefix implements elldb.DB
func (mmDeleteByPrefix *DBMock) DeleteByPrefix(ba1 []byte) (err error) {
	mm_atomic.AddUint64(&mmDeleteByPrefix.beforeDeleteByPrefixCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteByPrefix.afterDeleteByPrefixCounter, 1)

	if mmDeleteByPrefix.inspectFuncDeleteByPrefix != nil {
		mmDeleteByPrefix.inspectFuncDeleteByPrefix(ba1)
	}

	mm_params := &DBMockDeleteByPrefixParams{ba1}

	// Record call args
	mmDeleteByPrefix.DeleteByPrefixMock.mutex.Lock()
	mmDeleteByPrefix.DeleteByPrefixMock.callArgs = append(mmDeleteByPrefix.DeleteByPrefixMock.callArgs, mm_params)
	mmDeleteByPrefix.DeleteByPrefixMock.mutex.Unlock()

	for _, e := range mmDeleteByPrefix.DeleteByPrefixMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteByPrefix.DeleteByPrefixMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteByPrefix.DeleteByPrefixMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteByPrefix.DeleteByPrefixMock.defaultExpectation.params
		mm_got := DBMockDeleteByPrefixParams{ba1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteByPrefix.t.Errorf("DBMock.DeleteByPrefix got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteByPrefix.DeleteByPrefixMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteByPrefix.t.Fatal("No results are set for the DBMock.DeleteByPrefix")
		}
		return (*mm_results).err
	}
	if mmDeleteByPrefix.funcDeleteByPrefix != nil {
		return mmDeleteByPrefix.funcDeleteByPrefix(ba1)
	}
	mmDeleteByPrefix.t.Fatalf("Unexpected call to DBMock.DeleteByPrefix. %v", ba1)
	return
}

// DeleteByPrefixAfterCounter returns a count of finished DBMock.DeleteByPrefix invocations
func (mmDeleteByPrefix *DBMock) DeleteByPrefixAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByPrefix.afterDeleteByPrefixCounter)
}

// DeleteByPrefixBeforeCounter returns a count of DBMock.DeleteByPrefix invocations
func (mmDeleteByPrefix *DBMock) DeleteByPrefixBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByPrefix.beforeDeleteByPrefixCounter)
}

// Calls returns a list of arguments used in each call to DBMock.DeleteByPrefix.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteByPrefix *mDBMockDeleteByPrefix) Calls() []*DBMockDeleteByPrefixParams {
	mmDeleteByPrefix.mutex.RLock()

	argCopy := make([]*DBMockDeleteByPrefixParams, len(mmDeleteByPrefix.callArgs))
	copy(argCopy, mmDeleteByPrefix.callArgs)

	mmDeleteByPrefix.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteByPrefixDone returns true if the count of the DeleteByPrefix invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockDeleteByPrefixDone() bool {
	for _, e := range m.DeleteByPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByPrefixCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByPrefix != nil && mm_atomic.LoadUint64(&m.afterDeleteByPrefixCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteByPrefixInspect logs each unmet expectation
func (m *DBMock) MinimockDeleteByPrefixInspect() {
	for _, e := range m.DeleteByPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.DeleteByPrefix with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByPrefixCounter) < 1 {
		if m.DeleteByPrefixMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.DeleteByPrefix")
		} else {
			m.t.Errorf("Expected call to DBMock.DeleteByPrefix with params: %#v", *m.DeleteByPrefixMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByPrefix != nil && mm_atomic.LoadUint64(&m.afterDeleteByPrefixCounter) < 1 {
		m.t.Error("Expected call to DBMock.DeleteByPrefix")
	}
}

type mDBMockGetByPrefix struct {
	mock               *DBMock
	defaultExpectation *DBMockGetByPrefixExpectation
	expectations       []*DBMockGetByPrefixExpectation

	callArgs []*DBMockGetByPrefixParams
	mutex    sync.RWMutex
}

// DBMockGetByPrefixExpectation specifies expectation struct of the DB.GetByPrefix
type DBMockGetByPrefixExpectation struct {
	mock    *DBMock
	params  *DBMockGetByPrefixParams
	results *DBMockGetByPrefixResults
	Counter uint64
}

// DBMockGetByPrefixParams contains parameters of the DB.GetByPrefix
type DBMockGetByPrefixParams struct {
	ba1 []byte
}

// DBMockGetByPrefixResults contains results of the DB.GetByPrefix
type DBMockGetByPrefixResults struct {
	result []*mm_elldb.KVObject
}

// Expect sets up expected params for DB.GetByPrefix
func (mmGetByPrefix *mDBMockGetByPrefix) Expect(ba1 []byte) *mDBMockGetByPrefix {
	if mmGetByPrefix.mock.funcGetByPrefix != nil {
		mmGetByPrefix.mock.t.Fatalf("DBMock.GetByPrefix mock is already set by Set")
	}

	if mmGetByPrefix.defaultExpectation == nil {
		mmGetByPrefix.defaultExpectation = &DBMockGetByPrefixExpectation{}
	}

	mmGetByPrefix.defaultExpectation.params = &DBMockGetByPrefixParams{ba1}
	for _, e := range mmGetByPrefix.expectations {
		if minimock.Equal(e.params, mmGetByPrefix.defaultExpectation.params) {
			mmGetByPrefix.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByPrefix.defaultExpectation.params)
		}
	}

	return mmGetByPrefix
}

// Inspect accepts an inspector function that has same arguments as the DB.GetByPrefix
func (mmGetByPrefix *mDBMockGetByPrefix) Inspect(f func(ba1 []byte)) *mDBMockGetByPrefix {
	if mmGetByPrefix.mock.inspectFuncGetByPrefix != nil {
		mmGetByPrefix.mock.t.Fatalf("Inspect function is already set for DBMock.GetByPrefix")
	}

	mmGetByPrefix.mock.inspectFuncGetByPrefix = f

	return mmGetByPrefix
}

// Return sets up results that will be returned by DB.GetByPrefix
func (mmGetByPrefix *mDBMockGetByPrefix) Return(result []*mm_elldb.KVObject) *DBMock {
	if mmGetByPrefix.mock.funcGetByPrefix != nil {
		mmGetByPrefix.mock.t.Fatalf("DBMock.GetByPrefix mock is already set by Set")
	}

	if mmGetByPrefix.defaultExpectation == nil {
		mmGetByPrefix.defaultExpectation = &DBMockGetByPrefixExpectation{mock: mmGetByPrefix.mock}
	}
	mmGetByPrefix.defaultExpectation.results = &DBMockGetByPrefixResults{result}
	return mmGetByPrefix.mock
}

//Set uses given function f to mock the DB.GetByPrefix method
func (mmGetByPrefix *mDBMockGetByPrefix) Set(f func(ba1 []byte) (result []*mm_elldb.KVObject)) *DBMock {
	if mmGetByPrefix.defaultExpectation != nil {
		mmGetByPrefix.mock.t.Fatalf("Default expectation is already set for the DB.GetByPrefix method")
	}

	if len(mmGetByPrefix.expectations) > 0 {
		mmGetByPrefix.mock.t.Fatalf("Some expectations are already set for the DB.GetByPrefix method")
	}

	mmGetByPrefix.mock.funcGetByPrefix = f
	return mmGetByPrefix.mock
}

// When sets expectation for the DB.GetByPrefix which will trigger the result defined by the following
// Then helper
func (mmGetByPrefix *mDBMockGetByPrefix) When(ba1 []byte) *DBMockGetByPrefixExpectation {
	if mmGetByPrefix.mock.funcGetByPrefix != nil {
		mmGetByPrefix.mock.t.Fatalf("DBMock.GetByPrefix mock is already set by Set")
	}

	expectation := &DBMockGetByPrefixExpectation{
		mock:   mmGetByPrefix.mock,
		params: &DBMockGetByPrefixParams{ba1},
	}
	mmGetByPrefix.expectations = append(mmGetByPrefix.expectations, expectation)
	return expectation
}

// Then sets up DB.GetByPrefix return parameters for the expectation previously defined by the When method
func (e *DBMockGetByPrefixExpectation) Then(result []*mm_elldb.KVObject) *DBMock {
	e.results = &DBMockGetByPrefixResults{result}
	return e.mock
}

// GetByPrefix implements elldb.DB
func (mmGetByPrefix *DBMock) GetByPrefix(ba1 []byte) (result []*mm_elldb.KVObject) {
	mm_atomic.AddUint64(&mmGetByPrefix.beforeGetByPrefixCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByPrefix.afterGetByPrefixCounter, 1)

	if mmGetByPrefix.inspectFuncGetByPrefix != nil {
		mmGetByPrefix.inspectFuncGetByPrefix(ba1)
	}

	mm_params := &DBMockGetByPrefixParams{ba1}

	// Record call args
	mmGetByPrefix.GetByPrefixMock.mutex.Lock()
	mmGetByPrefix.GetByPrefixMock.callArgs = append(mmGetByPrefix.GetByPrefixMock.callArgs, mm_params)
	mmGetByPrefix.GetByPrefixMock.mutex.Unlock()

	for _, e := range mmGetByPrefix.GetByPrefixMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.result
		}
	}

	if mmGetByPrefix.GetByPrefixMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByPrefix.GetByPrefixMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByPrefix.GetByPrefixMock.defaultExpectation.params
		mm_got := DBMockGetByPrefixParams{ba1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByPrefix.t.Errorf("DBMock.GetByPrefix got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByPrefix.GetByPrefixMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByPrefix.t.Fatal("No results are set for the DBMock.GetByPrefix")
		}
		return (*mm_results).result
	}
	if mmGetByPrefix.funcGetByPrefix != nil {
		return mmGetByPrefix.funcGetByPrefix(ba1)
	}
	mmGetByPrefix.t.Fatalf("Unexpected call to DBMock.GetByPrefix. %v", ba1)
	return
}

// GetByPrefixAfterCounter returns a count of finished DBMock.GetByPrefix invocations
func (mmGetByPrefix *DBMock) GetByPrefixAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByPrefix.afterGetByPrefixCounter)
}

// GetByPrefixBeforeCounter returns a count of DBMock.GetByPrefix invocations
func (mmGetByPrefix *DBMock) GetByPrefixBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByPrefix.beforeGetByPrefixCounter)
}

// Calls returns a list of arguments used in each call to DBMock.GetByPrefix.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByPrefix *mDBMockGetByPrefix) Calls() []*DBMockGetByPrefixParams {
	mmGetByPrefix.mutex.RLock()

	argCopy := make([]*DBMockGetByPrefixParams, len(mmGetByPrefix.callArgs))
	copy(argCopy, mmGetByPrefix.callArgs)

	mmGetByPrefix.mutex.RUnlock()

	return argCopy
}

// MinimockGetByPrefixDone returns true if the count of the GetByPrefix invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockGetByPrefixDone() bool {
	for _, e := range m.GetByPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByPrefixCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByPrefix != nil && mm_atomic.LoadUint64(&m.afterGetByPrefixCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByPrefixInspect logs each unmet expectation
func (m *DBMock) MinimockGetByPrefixInspect() {
	for _, e := range m.GetByPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.GetByPrefix with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByPrefixCounter) < 1 {
		if m.GetByPrefixMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.GetByPrefix")
		} else {
			m.t.Errorf("Expected call to DBMock.GetByPrefix with params: %#v", *m.GetByPrefixMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByPrefix != nil && mm_atomic.LoadUint64(&m.afterGetByPrefixCounter) < 1 {
		m.t.Error("Expected call to DBMock.GetByPrefix")
	}
}

type mDBMockGetFirstOrLast struct {
	mock               *DBMock
	defaultExpectation *DBMockGetFirstOrLastExpectation
	expectations       []*DBMockGetFirstOrLastExpectation

	callArgs []*DBMockGetFirstOrLastParams
	mutex    sync.RWMutex
}

// DBMockGetFirstOrLastExpectation specifies expectation struct of the DB.GetFirstOrLast
type DBMockGetFirstOrLastExpectation struct {
	mock    *DBMock
	params  *DBMockGetFirstOrLastParams
	results *DBMockGetFirstOrLastResults
	Counter uint64
}

// DBMockGetFirstOrLastParams contains parameters of the DB.GetFirstOrLast
type DBMockGetFirstOrLastParams struct {
	prefix []byte
	first  bool
}

// DBMockGetFirstOrLastResults contains results of the DB.GetFirstOrLast
type DBMockGetFirstOrLastResults struct {
	kp1 *mm_elldb.KVObject
}

// Expect sets up expected params for DB.GetFirstOrLast
func (mmGetFirstOrLast *mDBMockGetFirstOrLast) Expect(prefix []byte, first bool) *mDBMockGetFirstOrLast {
	if mmGetFirstOrLast.mock.funcGetFirstOrLast != nil {
		mmGetFirstOrLast.mock.t.Fatalf("DBMock.GetFirstOrLast mock is already set by Set")
	}

	if mmGetFirstOrLast.defaultExpectation == nil {
		mmGetFirstOrLast.defaultExpectation = &DBMockGetFirstOrLastExpectation{}
	}

	mmGetFirstOrLast.defaultExpectation.params = &DBMockGetFirstOrLastParams{prefix, first}
	for _, e := range mmGetFirstOrLast.expectations {
		if minimock.Equal(e.params, mmGetFirstOrLast.defaultExpectation.params) {
			mmGetFirstOrLast.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFirstOrLast.defaultExpectation.params)
		}
	}

	return mmGetFirstOrLast
}

// Inspect accepts an inspector function that has same arguments as the DB.GetFirstOrLast
func (mmGetFirstOrLast *mDBMockGetFirstOrLast) Inspect(f func(prefix []byte, first bool)) *mDBMockGetFirstOrLast {
	if mmGetFirstOrLast.mock.inspectFuncGetFirstOrLast != nil {
		mmGetFirstOrLast.mock.t.Fatalf("Inspect function is already set for DBMock.GetFirstOrLast")
	}

	mmGetFirstOrLast.mock.inspectFuncGetFirstOrLast = f

	return mmGetFirstOrLast
}

// Return sets up results that will be returned by DB.GetFirstOrLast
func (mmGetFirstOrLast *mDBMockGetFirstOrLast) Return(kp1 *mm_elldb.KVObject) *DBMock {
	if mmGetFirstOrLast.mock.funcGetFirstOrLast != nil {
		mmGetFirstOrLast.mock.t.Fatalf("DBMock.GetFirstOrLast mock is already set by Set")
	}

	if mmGetFirstOrLast.defaultExpectation == nil {
		mmGetFirstOrLast.defaultExpectation = &DBMockGetFirstOrLastExpectation{mock: mmGetFirstOrLast.mock}
	}
	mmGetFirstOrLast.defaultExpectation.results = &DBMockGetFirstOrLastResults{kp1}
	return mmGetFirstOrLast.mock
}

//Set uses given function f to mock the DB.GetFirstOrLast method
func (mmGetFirstOrLast *mDBMockGetFirstOrLast) Set(f func(prefix []byte, first bool) (kp1 *mm_elldb.KVObject)) *DBMock {
	if mmGetFirstOrLast.defaultExpectation != nil {
		mmGetFirstOrLast.mock.t.Fatalf("Default expectation is already set for the DB.GetFirstOrLast method")
	}

	if len(mmGetFirstOrLast.expectations) > 0 {
		mmGetFirstOrLast.mock.t.Fatalf("Some expectations are already set for the DB.GetFirstOrLast method")
	}

	mmGetFirstOrLast.mock.funcGetFirstOrLast = f
	return mmGetFirstOrLast.mock
}

// When sets expectation for the DB.GetFirstOrLast which will trigger the result defined by the following
// Then helper
func (mmGetFirstOrLast *mDBMockGetFirstOrLast) When(prefix []byte, first bool) *DBMockGetFirstOrLastExpectation {
	if mmGetFirstOrLast.mock.funcGetFirstOrLast != nil {
		mmGetFirstOrLast.mock.t.Fatalf("DBMock.GetFirstOrLast mock is already set by Set")
	}

	expectation := &DBMockGetFirstOrLastExpectation{
		mock:   mmGetFirstOrLast.mock,
		params: &DBMockGetFirstOrLastParams{prefix, first},
	}
	mmGetFirstOrLast.expectations = append(mmGetFirstOrLast.expectations, expectation)
	return expectation
}

// Then sets up DB.GetFirstOrLast return parameters for the expectation previously defined by the When method
func (e *DBMockGetFirstOrLastExpectation) Then(kp1 *mm_elldb.KVObject) *DBMock {
	e.results = &DBMockGetFirstOrLastResults{kp1}
	return e.mock
}

// GetFirstOrLast implements elldb.DB
func (mmGetFirstOrLast *DBMock) GetFirstOrLast(prefix []byte, first bool) (kp1 *mm_elldb.KVObject) {
	mm_atomic.AddUint64(&mmGetFirstOrLast.beforeGetFirstOrLastCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFirstOrLast.afterGetFirstOrLastCounter, 1)

	if mmGetFirstOrLast.inspectFuncGetFirstOrLast != nil {
		mmGetFirstOrLast.inspectFuncGetFirstOrLast(prefix, first)
	}

	mm_params := &DBMockGetFirstOrLastParams{prefix, first}

	// Record call args
	mmGetFirstOrLast.GetFirstOrLastMock.mutex.Lock()
	mmGetFirstOrLast.GetFirstOrLastMock.callArgs = append(mmGetFirstOrLast.GetFirstOrLastMock.callArgs, mm_params)
	mmGetFirstOrLast.GetFirstOrLastMock.mutex.Unlock()

	for _, e := range mmGetFirstOrLast.GetFirstOrLastMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1
		}
	}

	if mmGetFirstOrLast.GetFirstOrLastMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFirstOrLast.GetFirstOrLastMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFirstOrLast.GetFirstOrLastMock.defaultExpectation.params
		mm_got := DBMockGetFirstOrLastParams{prefix, first}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFirstOrLast.t.Errorf("DBMock.GetFirstOrLast got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFirstOrLast.GetFirstOrLastMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFirstOrLast.t.Fatal("No results are set for the DBMock.GetFirstOrLast")
		}
		return (*mm_results).kp1
	}
	if mmGetFirstOrLast.funcGetFirstOrLast != nil {
		return mmGetFirstOrLast.funcGetFirstOrLast(prefix, first)
	}
	mmGetFirstOrLast.t.Fatalf("Unexpected call to DBMock.GetFirstOrLast. %v %v", prefix, first)
	return
}

// GetFirstOrLastAfterCounter returns a count of finished DBMock.GetFirstOrLast invocations
func (mmGetFirstOrLast *DBMock) GetFirstOrLastAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFirstOrLast.afterGetFirstOrLastCounter)
}

// GetFirstOrLastBeforeCounter returns a count of DBMock.GetFirstOrLast invocations
func (mmGetFirstOrLast *DBMock) GetFirstOrLastBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFirstOrLast.beforeGetFirstOrLastCounter)
}

// Calls returns a list of arguments used in each call to DBMock.GetFirstOrLast.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFirstOrLast *mDBMockGetFirstOrLast) Calls() []*DBMockGetFirstOrLastParams {
	mmGetFirstOrLast.mutex.RLock()

	argCopy := make([]*DBMockGetFirstOrLastParams, len(mmGetFirstOrLast.callArgs))
	copy(argCopy, mmGetFirstOrLast.callArgs)

	mmGetFirstOrLast.mutex.RUnlock()

	return argCopy
}

// MinimockGetFirstOrLastDone returns true if the count of the GetFirstOrLast invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockGetFirstOrLastDone() bool {
	for _, e := range m.GetFirstOrLastMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFirstOrLastMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFirstOrLastCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFirstOrLast != nil && mm_atomic.LoadUint64(&m.afterGetFirstOrLastCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFirstOrLastInspect logs each unmet expectation
func (m *DBMock) MinimockGetFirstOrLastInspect() {
	for _, e := range m.GetFirstOrLastMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.GetFirstOrLast with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFirstOrLastMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFirstOrLastCounter) < 1 {
		if m.GetFirstOrLastMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.GetFirstOrLast")
		} else {
			m.t.Errorf("Expected call to DBMock.GetFirstOrLast with params: %#v", *m.GetFirstOrLastMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFirstOrLast != nil && mm_atomic.LoadUint64(&m.afterGetFirstOrLastCounter) < 1 {
		m.t.Error("Expected call to DBMock.GetFirstOrLast")
	}
}

type mDBMockIterate struct {
	mock               *DBMock
	defaultExpectation *DBMockIterateExpectation
	expectations       []*DBMockIterateExpectation

	callArgs []*DBMockIterateParams
	mutex    sync.RWMutex
}

// DBMockIterateExpectation specifies expectation struct of the DB.Iterate
type DBMockIterateExpectation struct {
	mock    *DBMock
	params  *DBMockIterateParams
	results *DBMockIterateResults
	Counter uint64
}

// DBMockIterateParams contains parameters of the DB.Iterate
type DBMockIterateParams struct {
	prefix   []byte
	first    bool
	iterFunc func(kv *mm_elldb.KVObject) bool
}

// DBMockIterateResults contains results of the DB.Iterate
type DBMockIterateResults struct {
	err error
}

// Expect sets up expected params for DB.Iterate
func (mmIterate *mDBMockIterate) Expect(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool) *mDBMockIterate {
	if mmIterate.mock.funcIterate != nil {
		mmIterate.mock.t.Fatalf("DBMock.Iterate mock is already set by Set")
	}

	if mmIterate.defaultExpectation == nil {
		mmIterate.defaultExpectation = &DBMockIterateExpectation{}
	}

	mmIterate.defaultExpectation.params = &DBMockIterateParams{prefix, first, iterFunc}
	for _, e := range mmIterate.expectations {
		if minimock.Equal(e.params, mmIterate.defaultExpectation.params) {
			mmIterate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIterate.defaultExpectation.params)
		}
	}

	return mmIterate
}

// Inspect accepts an inspector function that has same arguments as the DB.Iterate
func (mmIterate *mDBMockIterate) Inspect(f func(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool)) *mDBMockIterate {
	if mmIterate.mock.inspectFuncIterate != nil {
		mmIterate.mock.t.Fatalf("Inspect function is already set for DBMock.Iterate")
	}

	mmIterate.mock.inspectFuncIterate = f

	return mmIterate
}

// Return sets up results that will be returned by DB.Iterate
func (mmIterate *mDBMockIterate) Return(err error) *DBMock {
	if mmIterate.mock.funcIterate != nil {
		mmIterate.mock.t.Fatalf("DBMock.Iterate mock is already set by Set")
	}

	if mmIterate.defaultExpectation == nil {
		mmIterate.defaultExpectation = &DBMockIterateExpectation{mock: mmIterate.mock}
	}
	mmIterate.defaultExpectation.results = &DBMockIterateResults{err}
	return mmIterate.mock
}

//Set uses given function f to mock the DB.Iterate method
func (mmIterate *mDBMockIterate) Set(f func(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool) (err error)) *DBMock {
	if mmIterate.defaultExpectation != nil {
		mmIterate.mock.t.Fatalf("Default expectation is already set for the DB.Iterate method")
	}

	if len(mmIterate.expectations) > 0 {
		mmIterate.mock.t.Fatalf("Some expectations are already set for the DB.Iterate method")
	}

	mmIterate.mock.funcIterate = f
	return mmIterate.mock
}

// When sets expectation for the DB.Iterate which will trigger the result defined by the following
// Then helper
func (mmIterate *mDBMockIterate) When(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool) *DBMockIterateExpectation {
	if mmIterate.mock.funcIterate != nil {
		mmIterate.mock.t.Fatalf("DBMock.Iterate mock is already set by Set")
	}

	expectation := &DBMockIterateExpectation{
		mock:   mmIterate.mock,
		params: &DBMockIterateParams{prefix, first, iterFunc},
	}
	mmIterate.expectations = append(mmIterate.expectations, expectation)
	return expectation
}

// Then sets up DB.Iterate return parameters for the expectation previously defined by the When method
func (e *DBMockIterateExpectation) Then(err error) *DBMock {
	e.results = &DBMockIterateResults{err}
	return e.mock
}

// Iterate implements elldb.DB
func (mmIterate *DBMock) Iterate(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool) (err error) {
	mm_atomic.AddUint64(&mmIterate.beforeIterateCounter, 1)
	defer mm_atomic.AddUint64(&mmIterate.afterIterateCounter, 1)

	if mmIterate.inspectFuncIterate != nil {
		mmIterate.inspectFuncIterate(prefix, first, iterFunc)
	}

	mm_params := &DBMockIterateParams{prefix, first, iterFunc}

	// Record call args
	mmIterate.IterateMock.mutex.Lock()
	mmIterate.IterateMock.callArgs = append(mmIterate.IterateMock.callArgs, mm_params)
	mmIterate.IterateMock.mutex.Unlock()

	for _, e := range mmIterate.IterateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIterate.IterateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIterate.IterateMock.defaultExpectation.Counter, 1)
		mm_want := mmIterate.IterateMock.defaultExpectation.params
		mm_got := DBMockIterateParams{prefix, first, iterFunc}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIterate.t.Errorf("DBMock.Iterate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIterate.IterateMock.defaultExpectation.results
		if mm_results == nil {
			mmIterate.t.Fatal("No results are set for the DBMock.Iterate")
		}
		return (*mm_results).err
	}
	if mmIterate.funcIterate != nil {
		return mmIterate.funcIterate(prefix, first, iterFunc)
	}
	mmIterate.t.Fatalf("Unexpected call to DBMock.Iterate. %v %v %v", prefix, first, iterFunc)
	return
}

// IterateAfterCounter returns a count of finished DBMock.Iterate invocations
func (mmIterate *DBMock) IterateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIterate.afterIterateCounter)
}

// IterateBeforeCounter returns a count of DBMock.Iterate invocations
func (mmIterate *DBMock) IterateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIterate.beforeIterateCounter)
}

// Calls returns a list of arguments used in each call to DBMock.Iterate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIterate *mDBMockIterate) Calls() []*DBMockIterateParams {
	mmIterate.mutex.RLock()

	argCopy := make([]*DBMockIterateParams, len(mmIterate.callArgs))
	copy(argCopy, mmIterate.callArgs)

	mmIterate.mutex.RUnlock()

	return argCopy
}

// MinimockIterateDone returns true if the count of the Iterate invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockIterateDone() bool {
	for _, e := range m.IterateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IterateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIterateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIterate != nil && mm_atomic.LoadUint64(&m.afterIterateCounter) < 1 {
		return false
	}
	return true
}

// MinimockIterateInspect logs each unmet expectation
func (m *DBMock) MinimockIterateInspect() {
	for _, e := range m.IterateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.Iterate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IterateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIterateCounter) < 1 {
		if m.IterateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.Iterate")
		} else {
			m.t.Errorf("Expected call to DBMock.Iterate with params: %#v", *m.IterateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIterate != nil && mm_atomic.LoadUint64(&m.afterIterateCounter) < 1 {
		m.t.Error("Expected call to DBMock.Iterate")
	}
}

type mDBMockNewTx struct {
	mock               *DBMock
	defaultExpectation *DBMockNewTxExpectation
	expectations       []*DBMockNewTxExpectation
}

// DBMockNewTxExpectation specifies expectation struct of the DB.NewTx
type DBMockNewTxExpectation struct {
	mock *DBMock

	results *DBMockNewTxResults
	Counter uint64
}

// DBMockNewTxResults contains results of the DB.NewTx
type DBMockNewTxResults struct {
	t1  mm_elldb.Tx
	err error
}

// Expect sets up expected params for DB.NewTx
func (mmNewTx *mDBMockNewTx) Expect() *mDBMockNewTx {
	if mmNewTx.mock.funcNewTx != nil {
		mmNewTx.mock.t.Fatalf("DBMock.NewTx mock is already set by Set")
	}

	if mmNewTx.defaultExpectation == nil {
		mmNewTx.defaultExpectation = &DBMockNewTxExpectation{}
	}

	return mmNewTx
}

// Inspect accepts an inspector function that has same arguments as the DB.NewTx
func (mmNewTx *mDBMockNewTx) Inspect(f func()) *mDBMockNewTx {
	if mmNewTx.mock.inspectFuncNewTx != nil {
		mmNewTx.mock.t.Fatalf("Inspect function is already set for DBMock.NewTx")
	}

	mmNewTx.mock.inspectFuncNewTx = f

	return mmNewTx
}

// Return sets up results that will be returned by DB.NewTx
func (mmNewTx *mDBMockNewTx) Return(t1 mm_elldb.Tx, err error) *DBMock {
	if mmNewTx.mock.funcNewTx != nil {
		mmNewTx.mock.t.Fatalf("DBMock.NewTx mock is already set by Set")
	}

	if mmNewTx.defaultExpectation == nil {
		mmNewTx.defaultExpectation = &DBMockNewTxExpectation{mock: mmNewTx.mock}
	}
	mmNewTx.defaultExpectation.results = &DBMockNewTxResults{t1, err}
	return mmNewTx.mock
}

//Set uses given function f to mock the DB.NewTx method
func (mmNewTx *mDBMockNewTx) Set(f func() (t1 mm_elldb.Tx, err error)) *DBMock {
	if mmNewTx.defaultExpectation != nil {
		mmNewTx.mock.t.Fatalf("Default expectation is already set for the DB.NewTx method")
	}

	if len(mmNewTx.expectations) > 0 {
		mmNewTx.mock.t.Fatalf("Some expectations are already set for the DB.NewTx method")
	}

	mmNewTx.mock.funcNewTx = f
	return mmNewTx.mock
}

// NewTx implements elldb.DB
func (mmNewTx *DBMock) NewTx() (t1 mm_elldb.Tx, err error) {
	mm_atomic.AddUint64(&mmNewTx.beforeNewTxCounter, 1)
	defer mm_atomic.AddUint64(&mmNewTx.afterNewTxCounter, 1)

	if mmNewTx.inspectFuncNewTx != nil {
		mmNewTx.inspectFuncNewTx()
	}

	if mmNewTx.NewTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewTx.NewTxMock.defaultExpectation.Counter, 1)

		mm_results := mmNewTx.NewTxMock.defaultExpectation.results
		if mm_results == nil {
			mmNewTx.t.Fatal("No results are set for the DBMock.NewTx")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmNewTx.funcNewTx != nil {
		return mmNewTx.funcNewTx()
	}
	mmNewTx.t.Fatalf("Unexpected call to DBMock.NewTx.")
	return
}

// NewTxAfterCounter returns a count of finished DBMock.NewTx invocations
func (mmNewTx *DBMock) NewTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewTx.afterNewTxCounter)
}

// NewTxBeforeCounter returns a count of DBMock.NewTx invocations
func (mmNewTx *DBMock) NewTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewTx.beforeNewTxCounter)
}

// MinimockNewTxDone returns true if the count of the NewTx invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockNewTxDone() bool {
	for _, e := range m.NewTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewTxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewTx != nil && mm_atomic.LoadUint64(&m.afterNewTxCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewTxInspect logs each unmet expectation
func (m *DBMock) MinimockNewTxInspect() {
	for _, e := range m.NewTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DBMock.NewTx")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewTxCounter) < 1 {
		m.t.Error("Expected call to DBMock.NewTx")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewTx != nil && mm_atomic.LoadUint64(&m.afterNewTxCounter) < 1 {
		m.t.Error("Expected call to DBMock.NewTx")
	}
}

type mDBMockOpen struct {
	mock               *DBMock
	defaultExpectation *DBMockOpenExpectation
	expectations       []*DBMockOpenExpectation

	callArgs []*DBMockOpenParams
	mutex    sync.RWMutex
}

// DBMockOpenExpectation specifies expectation struct of the DB.Open
type DBMockOpenExpectation struct {
	mock    *DBMock
	params  *DBMockOpenParams
	results *DBMockOpenResults
	Counter uint64
}

// DBMockOpenParams contains parameters of the DB.Open
type DBMockOpenParams struct {
	namespace string
}

// DBMockOpenResults contains results of the DB.Open
type DBMockOpenResults struct {
	err error
}

// Expect sets up expected params for DB.Open
func (mmOpen *mDBMockOpen) Expect(namespace string) *mDBMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("DBMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &DBMockOpenExpectation{}
	}

	mmOpen.defaultExpectation.params = &DBMockOpenParams{namespace}
	for _, e := range mmOpen.expectations {
		if minimock.Equal(e.params, mmOpen.defaultExpectation.params) {
			mmOpen.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpen.defaultExpectation.params)
		}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the DB.Open
func (mmOpen *mDBMockOpen) Inspect(f func(namespace string)) *mDBMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for DBMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by DB.Open
func (mmOpen *mDBMockOpen) Return(err error) *DBMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("DBMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &DBMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &DBMockOpenResults{err}
	return mmOpen.mock
}

//Set uses given function f to mock the DB.Open method
func (mmOpen *mDBMockOpen) Set(f func(namespace string) (err error)) *DBMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the DB.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the DB.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// When sets expectation for the DB.Open which will trigger the result defined by the following
// Then helper
func (mmOpen *mDBMockOpen) When(namespace string) *DBMockOpenExpectation {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("DBMock.Open mock is already set by Set")
	}

	expectation := &DBMockOpenExpectation{
		mock:   mmOpen.mock,
		params: &DBMockOpenParams{namespace},
	}
	mmOpen.expectations = append(mmOpen.expectations, expectation)
	return expectation
}

// Then sets up DB.Open return parameters for the expectation previously defined by the When method
func (e *DBMockOpenExpectation) Then(err error) *DBMock {
	e.results = &DBMockOpenResults{err}
	return e.mock
}

// Open implements elldb.DB
func (mmOpen *DBMock) Open(namespace string) (err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen(namespace)
	}

	mm_params := &DBMockOpenParams{namespace}

	// Record call args
	mmOpen.OpenMock.mutex.Lock()
	mmOpen.OpenMock.callArgs = append(mmOpen.OpenMock.callArgs, mm_params)
	mmOpen.OpenMock.mutex.Unlock()

	for _, e := range mmOpen.OpenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)
		mm_want := mmOpen.OpenMock.defaultExpectation.params
		mm_got := DBMockOpenParams{namespace}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOpen.t.Errorf("DBMock.Open got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the DBMock.Open")
		}
		return (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen(namespace)
	}
	mmOpen.t.Fatalf("Unexpected call to DBMock.Open. %v", namespace)
	return
}

// OpenAfterCounter returns a count of finished DBMock.Open invocations
func (mmOpen *DBMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of DBMock.Open invocations
func (mmOpen *DBMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// Calls returns a list of arguments used in each call to DBMock.Open.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpen *mDBMockOpen) Calls() []*DBMockOpenParams {
	mmOpen.mutex.RLock()

	argCopy := make([]*DBMockOpenParams, len(mmOpen.callArgs))
	copy(argCopy, mmOpen.callArgs)

	mmOpen.mutex.RUnlock()

	return argCopy
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *DBMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.Open with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		if m.OpenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.Open")
		} else {
			m.t.Errorf("Expected call to DBMock.Open with params: %#v", *m.OpenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to DBMock.Open")
	}
}

type mDBMockPut struct {
	mock               *DBMock
	defaultExpectation *DBMockPutExpectation
	expectations       []*DBMockPutExpectation

	callArgs []*DBMockPutParams
	mutex    sync.RWMutex
}

// DBMockPutExpectation specifies expectation struct of the DB.Put
type DBMockPutExpectation struct {
	mock    *DBMock
	params  *DBMockPutParams
	results *DBMockPutResults
	Counter uint64
}

// DBMockPutParams contains parameters of the DB.Put
type DBMockPutParams struct {
	kpa1 []*mm_elldb.KVObject
}

// DBMockPutResults contains results of the DB.Put
type DBMockPutResults struct {
	err error
}

// Expect sets up expected params for DB.Put
func (mmPut *mDBMockPut) Expect(kpa1 []*mm_elldb.KVObject) *mDBMockPut {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("DBMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &DBMockPutExpectation{}
	}

	mmPut.defaultExpectation.params = &DBMockPutParams{kpa1}
	for _, e := range mmPut.expectations {
		if minimock.Equal(e.params, mmPut.defaultExpectation.params) {
			mmPut.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPut.defaultExpectation.params)
		}
	}

	return mmPut
}

// Inspect accepts an inspector function that has same arguments as the DB.Put
func (mmPut *mDBMockPut) Inspect(f func(kpa1 []*mm_elldb.KVObject)) *mDBMockPut {
	if mmPut.mock.inspectFuncPut != nil {
		mmPut.mock.t.Fatalf("Inspect function is already set for DBMock.Put")
	}

	mmPut.mock.inspectFuncPut = f

	return mmPut
}

// Return sets up results that will be returned by DB.Put
func (mmPut *mDBMockPut) Return(err error) *DBMock {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("DBMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &DBMockPutExpectation{mock: mmPut.mock}
	}
	mmPut.defaultExpectation.results = &DBMockPutResults{err}
	return mmPut.mock
}

//Set uses given function f to mock the DB.Put method
func (mmPut *mDBMockPut) Set(f func(kpa1 []*mm_elldb.KVObject) (err error)) *DBMock {
	if mmPut.defaultExpectation != nil {
		mmPut.mock.t.Fatalf("Default expectation is already set for the DB.Put method")
	}

	if len(mmPut.expectations) > 0 {
		mmPut.mock.t.Fatalf("Some expectations are already set for the DB.Put method")
	}

	mmPut.mock.funcPut = f
	return mmPut.mock
}

// When sets expectation for the DB.Put which will trigger the result defined by the following
// Then helper
func (mmPut *mDBMockPut) When(kpa1 []*mm_elldb.KVObject) *DBMockPutExpectation {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("DBMock.Put mock is already set by Set")
	}

	expectation := &DBMockPutExpectation{
		mock:   mmPut.mock,
		params: &DBMockPutParams{kpa1},
	}
	mmPut.expectations = append(mmPut.expectations, expectation)
	return expectation
}

// Then sets up DB.Put return parameters for the expectation previously defined by the When method
func (e *DBMockPutExpectation) Then(err error) *DBMock {
	e.results = &DBMockPutResults{err}
	return e.mock
}

// Put implements elldb.DB
func (mmPut *DBMock) Put(kpa1 []*mm_elldb.KVObject) (err error) {
	mm_atomic.AddUint64(&mmPut.beforePutCounter, 1)
	defer mm_atomic.AddUint64(&mmPut.afterPutCounter, 1)

	if mmPut.inspectFuncPut != nil {
		mmPut.inspectFuncPut(kpa1)
	}

	mm_params := &DBMockPutParams{kpa1}

	// Record call args
	mmPut.PutMock.mutex.Lock()
	mmPut.PutMock.callArgs = append(mmPut.PutMock.callArgs, mm_params)
	mmPut.PutMock.mutex.Unlock()

	for _, e := range mmPut.PutMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPut.PutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPut.PutMock.defaultExpectation.Counter, 1)
		mm_want := mmPut.PutMock.defaultExpectation.params
		mm_got := DBMockPutParams{kpa1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPut.t.Errorf("DBMock.Put got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPut.PutMock.defaultExpectation.results
		if mm_results == nil {
			mmPut.t.Fatal("No results are set for the DBMock.Put")
		}
		return (*mm_results).err
	}
	if mmPut.funcPut != nil {
		return mmPut.funcPut(kpa1)
	}
	mmPut.t.Fatalf("Unexpected call to DBMock.Put. %v", kpa1)
	return
}

// PutAfterCounter returns a count of finished DBMock.Put invocations
func (mmPut *DBMock) PutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.afterPutCounter)
}

// PutBeforeCounter returns a count of DBMock.Put invocations
func (mmPut *DBMock) PutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.beforePutCounter)
}

// Calls returns a list of arguments used in each call to DBMock.Put.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPut *mDBMockPut) Calls() []*DBMockPutParams {
	mmPut.mutex.RLock()

	argCopy := make([]*DBMockPutParams, len(mmPut.callArgs))
	copy(argCopy, mmPut.callArgs)

	mmPut.mutex.RUnlock()

	return argCopy
}

// MinimockPutDone returns true if the count of the Put invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockPutDone() bool {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	return true
}

// MinimockPutInspect logs each unmet expectation
func (m *DBMock) MinimockPutInspect() {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.Put with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		if m.PutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.Put")
		} else {
			m.t.Errorf("Expected call to DBMock.Put with params: %#v", *m.PutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		m.t.Error("Expected call to DBMock.Put")
	}
}

type mDBMockTruncate struct {
	mock               *DBMock
	defaultExpectation *DBMockTruncateExpectation
	expectations       []*DBMockTruncateExpectation
}

// DBMockTruncateExpectation specifies expectation struct of the DB.Truncate
type DBMockTruncateExpectation struct {
	mock *DBMock

	results *DBMockTruncateResults
	Counter uint64
}

// DBMockTruncateResults contains results of the DB.Truncate
type DBMockTruncateResults struct {
	err error
}

// Expect sets up expected params for DB.Truncate
func (mmTruncate *mDBMockTruncate) Expect() *mDBMockTruncate {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("DBMock.Truncate mock is already set by Set")
	}

	if mmTruncate.defaultExpectation == nil {
		mmTruncate.defaultExpectation = &DBMockTruncateExpectation{}
	}

	return mmTruncate
}

// Inspect accepts an inspector function that has same arguments as the DB.Truncate
func (mmTruncate *mDBMockTruncate) Inspect(f func()) *mDBMockTruncate {
	if mmTruncate.mock.inspectFuncTruncate != nil {
		mmTruncate.mock.t.Fatalf("Inspect function is already set for DBMock.Truncate")
	}

	mmTruncate.mock.inspectFuncTruncate = f

	return mmTruncate
}

// Return sets up results that will be returned by DB.Truncate
func (mmTruncate *mDBMockTruncate) Return(err error) *DBMock {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("DBMock.Truncate mock is already set by Set")
	}

	if mmTruncate.defaultExpectation == nil {
		mmTruncate.defaultExpectation = &DBMockTruncateExpectation{mock: mmTruncate.mock}
	}
	mmTruncate.defaultExpectation.results = &DBMockTruncateResults{err}
	return mmTruncate.mock
}

//Set uses given function f to mock the DB.Truncate method
func (mmTruncate *mDBMockTruncate) Set(f func() (err error)) *DBMock {
	if mmTruncate.defaultExpectation != nil {
		mmTruncate.mock.t.Fatalf("Default expectation is already set for the DB.Truncate method")
	}

	if len(mmTruncate.expectations) > 0 {
		mmTruncate.mock.t.Fatalf("Some expectations are already set for the DB.Truncate method")
	}

	mmTruncate.mock.funcTruncate = f
	return mmTruncate.mock
}

// Truncate implements elldb.DB
func (mmTruncate *DBMock) Truncate() (err error) {
	mm_atomic.AddUint64(&mmTruncate.beforeTruncateCounter, 1)
	defer mm_atomic.AddUint64(&mmTruncate.afterTruncateCounter, 1)

	if mmTruncate.inspectFuncTruncate != nil {
		mmTruncate.inspectFuncTruncate()
	}

	if mmTruncate.TruncateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTruncate.TruncateMock.defaultExpectation.Counter, 1)

		mm_results := mmTruncate.TruncateMock.defaultExpectation.results
		if mm_results == nil {
			mmTruncate.t.Fatal("No results are set for the DBMock.Truncate")
		}
		return (*mm_results).err
	}
	if mmTruncate.funcTruncate != nil {
		return mmTruncate.funcTruncate()
	}
	mmTruncate.t.Fatalf("Unexpected call to DBMock.Truncate.")
	return
}

// TruncateAfterCounter returns a count of finished DBMock.Truncate invocations
func (mmTruncate *DBMock) TruncateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncate.afterTruncateCounter)
}

// TruncateBeforeCounter returns a count of DBMock.Truncate invocations
func (mmTruncate *DBMock) TruncateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncate.beforeTruncateCounter)
}

// MinimockTruncateDone returns true if the count of the Truncate invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockTruncateDone() bool {
	for _, e := range m.TruncateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncate != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		return false
	}
	return true
}

// MinimockTruncateInspect logs each unmet expectation
func (m *DBMock) MinimockTruncateInspect() {
	for _, e := range m.TruncateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DBMock.Truncate")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		m.t.Error("Expected call to DBMock.Truncate")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncate != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		m.t.Error("Expected call to DBMock.Truncate")
	}
}

type mDBMockTruncateWithFunc struct {
	mock               *DBMock
	defaultExpectation *DBMockTruncateWithFuncExpectation
	expectations       []*DBMockTruncateWithFuncExpectation

	callArgs []*DBMockTruncateWithFuncParams
	mutex    sync.RWMutex
}

// DBMockTruncateWithFuncExpectation specifies expectation struct of the DB.TruncateWithFunc
type DBMockTruncateWithFuncExpectation struct {
	mock    *DBMock
	params  *DBMockTruncateWithFuncParams
	results *DBMockTruncateWithFuncResults
	Counter uint64
}

// DBMockTruncateWithFuncParams contains parameters of the DB.TruncateWithFunc
type DBMockTruncateWithFuncParams struct {
	prefix    []byte
	first     bool
	predicate func(kv *mm_elldb.KVObject) bool
}

// DBMockTruncateWithFuncResults contains results of the DB.TruncateWithFunc
type DBMockTruncateWithFuncResults struct {
	err error
}

// Expect sets up expected params for DB.TruncateWithFunc
func (mmTruncateWithFunc *mDBMockTruncateWithFunc) Expect(prefix []byte, first bool, predicate func(kv *mm_elldb.KVObject) bool) *mDBMockTruncateWithFunc {
	if mmTruncateWithFunc.mock.funcTruncateWithFunc != nil {
		mmTruncateWithFunc.mock.t.Fatalf("DBMock.TruncateWithFunc mock is already set by Set")
	}

	if mmTruncateWithFunc.defaultExpectation == nil {
		mmTruncateWithFunc.defaultExpectation = &DBMockTruncateWithFuncExpectation{}
	}

	mmTruncateWithFunc.defaultExpectation.params = &DBMockTruncateWithFuncParams{prefix, first, predicate}
	for _, e := range mmTruncateWithFunc.expectations {
		if minimock.Equal(e.params, mmTruncateWithFunc.defaultExpectation.params) {
			mmTruncateWithFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTruncateWithFunc.defaultExpectation.params)
		}
	}

	return mmTruncateWithFunc
}

// Inspect accepts an inspector function that has same arguments as the DB.TruncateWithFunc
func (mmTruncateWithFunc *mDBMockTruncateWithFunc) Inspect(f func(prefix []byte, first bool, predicate func(kv *mm_elldb.KVObject) bool)) *mDBMockTruncateWithFunc {
	if mmTruncateWithFunc.mock.inspectFuncTruncateWithFunc != nil {
		mmTruncateWithFunc.mock.t.Fatalf("Inspect function is already set for DBMock.TruncateWithFunc")
	}

	mmTruncateWithFunc.mock.inspectFuncTruncateWithFunc = f

	return mmTruncateWithFunc
}

// Return sets up results that will be returned by DB.TruncateWithFunc
func (mmTruncateWithFunc *mDBMockTruncateWithFunc) Return(err error) *DBMock {
	if mmTruncateWithFunc.mock.funcTruncateWithFunc != nil {
		mmTruncateWithFunc.mock.t.Fatalf("DBMock.TruncateWithFunc mock is already set by Set")
	}

	if mmTruncateWithFunc.defaultExpectation == nil {
		mmTruncateWithFunc.defaultExpectation = &DBMockTruncateWithFuncExpectation{mock: mmTruncateWithFunc.mock}
	}
	mmTruncateWithFunc.defaultExpectation.results = &DBMockTruncateWithFuncResults{err}
	return mmTruncateWithFunc.mock
}

//Set uses given function f to mock the DB.TruncateWithFunc method
func (mmTruncateWithFunc *mDBMockTruncateWithFunc) Set(f func(prefix []byte, first bool, predicate func(kv *mm_elldb.KVObject) bool) (err error)) *DBMock {
	if mmTruncateWithFunc.defaultExpectation != nil {
		mmTruncateWithFunc.mock.t.Fatalf("Default expectation is already set for the DB.TruncateWithFunc method")
	}

	if len(mmTruncateWithFunc.expectations) > 0 {
		mmTruncateWithFunc.mock.t.Fatalf("Some expectations are already set for the DB.TruncateWithFunc method")
	}

	mmTruncateWithFunc.mock.funcTruncateWithFunc = f
	return mmTruncateWithFunc.mock
}

// When sets expectation for the DB.TruncateWithFunc which will trigger the result defined by the following
// Then helper
func (mmTruncateWithFunc *mDBMockTruncateWithFunc) When(prefix []byte, first bool, predicate func(kv *mm_elldb.KVObject) bool) *DBMockTruncateWithFuncExpectation {
	if mmTruncateWithFunc.mock.funcTruncateWithFunc != nil {
		mmTruncateWithFunc.mock.t.Fatalf("DBMock.TruncateWithFunc mock is already set by Set")
	}

	expectation := &DBMockTruncateWithFuncExpectation{
		mock:   mmTruncateWithFunc.mock,
		params: &DBMockTruncateWithFuncParams{prefix, first, predicate},
	}
	mmTruncateWithFunc.expectations = append(mmTruncateWithFunc.expectations, expectation)
	return expectation
}

// Then sets up DB.TruncateWithFunc return parameters for the expectation previously defined by the When method
func (e *DBMockTruncateWithFuncExpectation) Then(err error) *DBMock {
	e.results = &DBMockTruncateWithFuncResults{err}
	return e.mock
}

// TruncateWithFunc implements elldb.DB
func (mmTruncateWithFunc *DBMock) TruncateWithFunc(prefix []byte, first bool, predicate func(kv *mm_elldb.KVObject) bool) (err error) {
	mm_atomic.AddUint64(&mmTruncateWithFunc.beforeTruncateWithFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmTruncateWithFunc.afterTruncateWithFuncCounter, 1)

	if mmTruncateWithFunc.inspectFuncTruncateWithFunc != nil {
		mmTruncateWithFunc.inspectFuncTruncateWithFunc(prefix, first, predicate)
	}

	mm_params := &DBMockTruncateWithFuncParams{prefix, first, predicate}

	// Record call args
	mmTruncateWithFunc.TruncateWithFuncMock.mutex.Lock()
	mmTruncateWithFunc.TruncateWithFuncMock.callArgs = append(mmTruncateWithFunc.TruncateWithFuncMock.callArgs, mm_params)
	mmTruncateWithFunc.TruncateWithFuncMock.mutex.Unlock()

	for _, e := range mmTruncateWithFunc.TruncateWithFuncMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTruncateWithFunc.TruncateWithFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTruncateWithFunc.TruncateWithFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmTruncateWithFunc.TruncateWithFuncMock.defaultExpectation.params
		mm_got := DBMockTruncateWithFuncParams{prefix, first, predicate}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTruncateWithFunc.t.Errorf("DBMock.TruncateWithFunc got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTruncateWithFunc.TruncateWithFuncMock.defaultExpectation.results
		if mm_results == nil {
			mmTruncateWithFunc.t.Fatal("No results are set for the DBMock.TruncateWithFunc")
		}
		return (*mm_results).err
	}
	if mmTruncateWithFunc.funcTruncateWithFunc != nil {
		return mmTruncateWithFunc.funcTruncateWithFunc(prefix, first, predicate)
	}
	mmTruncateWithFunc.t.Fatalf("Unexpected call to DBMock.TruncateWithFunc. %v %v %v", prefix, first, predicate)
	return
}

// TruncateWithFuncAfterCounter returns a count of finished DBMock.TruncateWithFunc invocations
func (mmTruncateWithFunc *DBMock) TruncateWithFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncateWithFunc.afterTruncateWithFuncCounter)
}

// TruncateWithFuncBeforeCounter returns a count of DBMock.TruncateWithFunc invocations
func (mmTruncateWithFunc *DBMock) TruncateWithFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncateWithFunc.beforeTruncateWithFuncCounter)
}

// Calls returns a list of arguments used in each call to DBMock.TruncateWithFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTruncateWithFunc *mDBMockTruncateWithFunc) Calls() []*DBMockTruncateWithFuncParams {
	mmTruncateWithFunc.mutex.RLock()

	argCopy := make([]*DBMockTruncateWithFuncParams, len(mmTruncateWithFunc.callArgs))
	copy(argCopy, mmTruncateWithFunc.callArgs)

	mmTruncateWithFunc.mutex.RUnlock()

	return argCopy
}

// MinimockTruncateWithFuncDone returns true if the count of the TruncateWithFunc invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockTruncateWithFuncDone() bool {
	for _, e := range m.TruncateWithFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateWithFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateWithFuncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncateWithFunc != nil && mm_atomic.LoadUint64(&m.afterTruncateWithFuncCounter) < 1 {
		return false
	}
	return true
}

// MinimockTruncateWithFuncInspect logs each unmet expectation
func (m *DBMock) MinimockTruncateWithFuncInspect() {
	for _, e := range m.TruncateWithFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.TruncateWithFunc with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateWithFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateWithFuncCounter) < 1 {
		if m.TruncateWithFuncMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.TruncateWithFunc")
		} else {
			m.t.Errorf("Expected call to DBMock.TruncateWithFunc with params: %#v", *m.TruncateWithFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncateWithFunc != nil && mm_atomic.LoadUint64(&m.afterTruncateWithFuncCounter) < 1 {
		m.t.Error("Expected call to DBMock.TruncateWithFunc")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockDeleteByPrefixInspect()

		m.MinimockGetByPrefixInspect()

		m.MinimockGetFirstOrLastInspect()

		m.MinimockIterateInspect()

		m.MinimockNewTxInspect()

		m.MinimockOpenInspect()

		m.MinimockPutInspect()

		m.MinimockTruncateInspect()

		m.MinimockTruncateWithFuncInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockDeleteByPrefixDone() &&
		m.MinimockGetByPrefixDone() &&
		m.MinimockGetFirstOrLastDone() &&
		m.MinimockIterateDone() &&
		m.MinimockNewTxDone() &&
		m.MinimockOpenDone() &&
		m.MinimockPutDone() &&
		m.MinimockTruncateDone() &&
		m.MinimockTruncateWithFuncDone()
}
