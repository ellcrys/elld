package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/ellcrys/elld/elldb.Tx -o ./mocks/tx_mock.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_elldb "github.com/ellcrys/elld/elldb"
	"github.com/gojuno/minimock"
)

// TxMock implements elldb.Tx
type TxMock struct {
	t minimock.Tester

	funcCommit          func() (err error)
	inspectFuncCommit   func()
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mTxMockCommit

	funcDeleteByPrefix          func(ba1 []byte) (err error)
	inspectFuncDeleteByPrefix   func(ba1 []byte)
	afterDeleteByPrefixCounter  uint64
	beforeDeleteByPrefixCounter uint64
	DeleteByPrefixMock          mTxMockDeleteByPrefix

	funcDiscard          func()
	inspectFuncDiscard   func()
	afterDiscardCounter  uint64
	beforeDiscardCounter uint64
	DiscardMock          mTxMockDiscard

	funcGetByPrefix          func(ba1 []byte) (result []*mm_elldb.KVObject)
	inspectFuncGetByPrefix   func(ba1 []byte)
	afterGetByPrefixCounter  uint64
	beforeGetByPrefixCounter uint64
	GetByPrefixMock          mTxMockGetByPrefix

	funcIterate          func(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool)
	inspectFuncIterate   func(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool)
	afterIterateCounter  uint64
	beforeIterateCounter uint64
	IterateMock          mTxMockIterate

	funcPut          func(kpa1 []*mm_elldb.KVObject) (err error)
	inspectFuncPut   func(kpa1 []*mm_elldb.KVObject)
	afterPutCounter  uint64
	beforePutCounter uint64
	PutMock          mTxMockPut

	funcRollback          func()
	inspectFuncRollback   func()
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mTxMockRollback
}

// NewTxMock returns a mock for elldb.Tx
func NewTxMock(t minimock.Tester) *TxMock {
	m := &TxMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CommitMock = mTxMockCommit{mock: m}

	m.DeleteByPrefixMock = mTxMockDeleteByPrefix{mock: m}
	m.DeleteByPrefixMock.callArgs = []*TxMockDeleteByPrefixParams{}

	m.DiscardMock = mTxMockDiscard{mock: m}

	m.GetByPrefixMock = mTxMockGetByPrefix{mock: m}
	m.GetByPrefixMock.callArgs = []*TxMockGetByPrefixParams{}

	m.IterateMock = mTxMockIterate{mock: m}
	m.IterateMock.callArgs = []*TxMockIterateParams{}

	m.PutMock = mTxMockPut{mock: m}
	m.PutMock.callArgs = []*TxMockPutParams{}

	m.RollbackMock = mTxMockRollback{mock: m}

	return m
}

type mTxMockCommit struct {
	mock               *TxMock
	defaultExpectation *TxMockCommitExpectation
	expectations       []*TxMockCommitExpectation
}

// TxMockCommitExpectation specifies expectation struct of the Tx.Commit
type TxMockCommitExpectation struct {
	mock *TxMock

	results *TxMockCommitResults
	Counter uint64
}

// TxMockCommitResults contains results of the Tx.Commit
type TxMockCommitResults struct {
	err error
}

// Expect sets up expected params for Tx.Commit
func (mmCommit *mTxMockCommit) Expect() *mTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{}
	}

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the Tx.Commit
func (mmCommit *mTxMockCommit) Inspect(f func()) *mTxMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for TxMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by Tx.Commit
func (mmCommit *mTxMockCommit) Return(err error) *TxMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &TxMockCommitResults{err}
	return mmCommit.mock
}

//Set uses given function f to mock the Tx.Commit method
func (mmCommit *mTxMockCommit) Set(f func() (err error)) *TxMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the Tx.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the Tx.Commit method")
	}

	mmCommit.mock.funcCommit = f
	return mmCommit.mock
}

// Commit implements elldb.Tx
func (mmCommit *TxMock) Commit() (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit()
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the TxMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit()
	}
	mmCommit.t.Fatalf("Unexpected call to TxMock.Commit.")
	return
}

// CommitAfterCounter returns a count of finished TxMock.Commit invocations
func (mmCommit *TxMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of TxMock.Commit invocations
func (mmCommit *TxMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockCommitDone() bool {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitInspect logs each unmet expectation
func (m *TxMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.Commit")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to TxMock.Commit")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to TxMock.Commit")
	}
}

type mTxMockDeleteByPrefix struct {
	mock               *TxMock
	defaultExpectation *TxMockDeleteByPrefixExpectation
	expectations       []*TxMockDeleteByPrefixExpectation

	callArgs []*TxMockDeleteByPrefixParams
	mutex    sync.RWMutex
}

// TxMockDeleteByPrefixExpectation specifies expectation struct of the Tx.DeleteByPrefix
type TxMockDeleteByPrefixExpectation struct {
	mock    *TxMock
	params  *TxMockDeleteByPrefixParams
	results *TxMockDeleteByPrefixResults
	Counter uint64
}

// TxMockDeleteByPrefixParams contains parameters of the Tx.DeleteByPrefix
type TxMockDeleteByPrefixParams struct {
	ba1 []byte
}

// TxMockDeleteByPrefixResults contains results of the Tx.DeleteByPrefix
type TxMockDeleteByPrefixResults struct {
	err error
}

// Expect sets up expected params for Tx.DeleteByPrefix
func (mmDeleteByPrefix *mTxMockDeleteByPrefix) Expect(ba1 []byte) *mTxMockDeleteByPrefix {
	if mmDeleteByPrefix.mock.funcDeleteByPrefix != nil {
		mmDeleteByPrefix.mock.t.Fatalf("TxMock.DeleteByPrefix mock is already set by Set")
	}

	if mmDeleteByPrefix.defaultExpectation == nil {
		mmDeleteByPrefix.defaultExpectation = &TxMockDeleteByPrefixExpectation{}
	}

	mmDeleteByPrefix.defaultExpectation.params = &TxMockDeleteByPrefixParams{ba1}
	for _, e := range mmDeleteByPrefix.expectations {
		if minimock.Equal(e.params, mmDeleteByPrefix.defaultExpectation.params) {
			mmDeleteByPrefix.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteByPrefix.defaultExpectation.params)
		}
	}

	return mmDeleteByPrefix
}

// Inspect accepts an inspector function that has same arguments as the Tx.DeleteByPrefix
func (mmDeleteByPrefix *mTxMockDeleteByPrefix) Inspect(f func(ba1 []byte)) *mTxMockDeleteByPrefix {
	if mmDeleteByPrefix.mock.inspectFuncDeleteByPrefix != nil {
		mmDeleteByPrefix.mock.t.Fatalf("Inspect function is already set for TxMock.DeleteByPrefix")
	}

	mmDeleteByPrefix.mock.inspectFuncDeleteByPrefix = f

	return mmDeleteByPrefix
}

// Return sets up results that will be returned by Tx.DeleteByPrefix
func (mmDeleteByPrefix *mTxMockDeleteByPrefix) Return(err error) *TxMock {
	if mmDeleteByPrefix.mock.funcDeleteByPrefix != nil {
		mmDeleteByPrefix.mock.t.Fatalf("TxMock.DeleteByPrefix mock is already set by Set")
	}

	if mmDeleteByPrefix.defaultExpectation == nil {
		mmDeleteByPrefix.defaultExpectation = &TxMockDeleteByPrefixExpectation{mock: mmDeleteByPrefix.mock}
	}
	mmDeleteByPrefix.defaultExpectation.results = &TxMockDeleteByPrefixResults{err}
	return mmDeleteByPrefix.mock
}

//Set uses given function f to mock the Tx.DeleteByPrefix method
func (mmDeleteByPrefix *mTxMockDeleteByPrefix) Set(f func(ba1 []byte) (err error)) *TxMock {
	if mmDeleteByPrefix.defaultExpectation != nil {
		mmDeleteByPrefix.mock.t.Fatalf("Default expectation is already set for the Tx.DeleteByPrefix method")
	}

	if len(mmDeleteByPrefix.expectations) > 0 {
		mmDeleteByPrefix.mock.t.Fatalf("Some expectations are already set for the Tx.DeleteByPrefix method")
	}

	mmDeleteByPrefix.mock.funcDeleteByPrefix = f
	return mmDeleteByPrefix.mock
}

// When sets expectation for the Tx.DeleteByPrefix which will trigger the result defined by the following
// Then helper
func (mmDeleteByPrefix *mTxMockDeleteByPrefix) When(ba1 []byte) *TxMockDeleteByPrefixExpectation {
	if mmDeleteByPrefix.mock.funcDeleteByPrefix != nil {
		mmDeleteByPrefix.mock.t.Fatalf("TxMock.DeleteByPrefix mock is already set by Set")
	}

	expectation := &TxMockDeleteByPrefixExpectation{
		mock:   mmDeleteByPrefix.mock,
		params: &TxMockDeleteByPrefixParams{ba1},
	}
	mmDeleteByPrefix.expectations = append(mmDeleteByPrefix.expectations, expectation)
	return expectation
}

// Then sets up Tx.DeleteByPrefix return parameters for the expectation previously defined by the When method
func (e *TxMockDeleteByPrefixExpectation) Then(err error) *TxMock {
	e.results = &TxMockDeleteByPrefixResults{err}
	return e.mock
}

// DeleteByPrefix implements elldb.Tx
func (mmDeleteByPrefix *TxMock) DeleteByPrefix(ba1 []byte) (err error) {
	mm_atomic.AddUint64(&mmDeleteByPrefix.beforeDeleteByPrefixCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteByPrefix.afterDeleteByPrefixCounter, 1)

	if mmDeleteByPrefix.inspectFuncDeleteByPrefix != nil {
		mmDeleteByPrefix.inspectFuncDeleteByPrefix(ba1)
	}

	mm_params := &TxMockDeleteByPrefixParams{ba1}

	// Record call args
	mmDeleteByPrefix.DeleteByPrefixMock.mutex.Lock()
	mmDeleteByPrefix.DeleteByPrefixMock.callArgs = append(mmDeleteByPrefix.DeleteByPrefixMock.callArgs, mm_params)
	mmDeleteByPrefix.DeleteByPrefixMock.mutex.Unlock()

	for _, e := range mmDeleteByPrefix.DeleteByPrefixMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteByPrefix.DeleteByPrefixMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteByPrefix.DeleteByPrefixMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteByPrefix.DeleteByPrefixMock.defaultExpectation.params
		mm_got := TxMockDeleteByPrefixParams{ba1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteByPrefix.t.Errorf("TxMock.DeleteByPrefix got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteByPrefix.DeleteByPrefixMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteByPrefix.t.Fatal("No results are set for the TxMock.DeleteByPrefix")
		}
		return (*mm_results).err
	}
	if mmDeleteByPrefix.funcDeleteByPrefix != nil {
		return mmDeleteByPrefix.funcDeleteByPrefix(ba1)
	}
	mmDeleteByPrefix.t.Fatalf("Unexpected call to TxMock.DeleteByPrefix. %v", ba1)
	return
}

// DeleteByPrefixAfterCounter returns a count of finished TxMock.DeleteByPrefix invocations
func (mmDeleteByPrefix *TxMock) DeleteByPrefixAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByPrefix.afterDeleteByPrefixCounter)
}

// DeleteByPrefixBeforeCounter returns a count of TxMock.DeleteByPrefix invocations
func (mmDeleteByPrefix *TxMock) DeleteByPrefixBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByPrefix.beforeDeleteByPrefixCounter)
}

// Calls returns a list of arguments used in each call to TxMock.DeleteByPrefix.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteByPrefix *mTxMockDeleteByPrefix) Calls() []*TxMockDeleteByPrefixParams {
	mmDeleteByPrefix.mutex.RLock()

	argCopy := make([]*TxMockDeleteByPrefixParams, len(mmDeleteByPrefix.callArgs))
	copy(argCopy, mmDeleteByPrefix.callArgs)

	mmDeleteByPrefix.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteByPrefixDone returns true if the count of the DeleteByPrefix invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockDeleteByPrefixDone() bool {
	for _, e := range m.DeleteByPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByPrefixCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByPrefix != nil && mm_atomic.LoadUint64(&m.afterDeleteByPrefixCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteByPrefixInspect logs each unmet expectation
func (m *TxMock) MinimockDeleteByPrefixInspect() {
	for _, e := range m.DeleteByPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.DeleteByPrefix with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByPrefixCounter) < 1 {
		if m.DeleteByPrefixMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.DeleteByPrefix")
		} else {
			m.t.Errorf("Expected call to TxMock.DeleteByPrefix with params: %#v", *m.DeleteByPrefixMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByPrefix != nil && mm_atomic.LoadUint64(&m.afterDeleteByPrefixCounter) < 1 {
		m.t.Error("Expected call to TxMock.DeleteByPrefix")
	}
}

type mTxMockDiscard struct {
	mock               *TxMock
	defaultExpectation *TxMockDiscardExpectation
	expectations       []*TxMockDiscardExpectation
}

// TxMockDiscardExpectation specifies expectation struct of the Tx.Discard
type TxMockDiscardExpectation struct {
	mock *TxMock

	Counter uint64
}

// Expect sets up expected params for Tx.Discard
func (mmDiscard *mTxMockDiscard) Expect() *mTxMockDiscard {
	if mmDiscard.mock.funcDiscard != nil {
		mmDiscard.mock.t.Fatalf("TxMock.Discard mock is already set by Set")
	}

	if mmDiscard.defaultExpectation == nil {
		mmDiscard.defaultExpectation = &TxMockDiscardExpectation{}
	}

	return mmDiscard
}

// Inspect accepts an inspector function that has same arguments as the Tx.Discard
func (mmDiscard *mTxMockDiscard) Inspect(f func()) *mTxMockDiscard {
	if mmDiscard.mock.inspectFuncDiscard != nil {
		mmDiscard.mock.t.Fatalf("Inspect function is already set for TxMock.Discard")
	}

	mmDiscard.mock.inspectFuncDiscard = f

	return mmDiscard
}

// Return sets up results that will be returned by Tx.Discard
func (mmDiscard *mTxMockDiscard) Return() *TxMock {
	if mmDiscard.mock.funcDiscard != nil {
		mmDiscard.mock.t.Fatalf("TxMock.Discard mock is already set by Set")
	}

	if mmDiscard.defaultExpectation == nil {
		mmDiscard.defaultExpectation = &TxMockDiscardExpectation{mock: mmDiscard.mock}
	}

	return mmDiscard.mock
}

//Set uses given function f to mock the Tx.Discard method
func (mmDiscard *mTxMockDiscard) Set(f func()) *TxMock {
	if mmDiscard.defaultExpectation != nil {
		mmDiscard.mock.t.Fatalf("Default expectation is already set for the Tx.Discard method")
	}

	if len(mmDiscard.expectations) > 0 {
		mmDiscard.mock.t.Fatalf("Some expectations are already set for the Tx.Discard method")
	}

	mmDiscard.mock.funcDiscard = f
	return mmDiscard.mock
}

// Discard implements elldb.Tx
func (mmDiscard *TxMock) Discard() {
	mm_atomic.AddUint64(&mmDiscard.beforeDiscardCounter, 1)
	defer mm_atomic.AddUint64(&mmDiscard.afterDiscardCounter, 1)

	if mmDiscard.inspectFuncDiscard != nil {
		mmDiscard.inspectFuncDiscard()
	}

	if mmDiscard.DiscardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDiscard.DiscardMock.defaultExpectation.Counter, 1)

		return

	}
	if mmDiscard.funcDiscard != nil {
		mmDiscard.funcDiscard()
		return
	}
	mmDiscard.t.Fatalf("Unexpected call to TxMock.Discard.")

}

// DiscardAfterCounter returns a count of finished TxMock.Discard invocations
func (mmDiscard *TxMock) DiscardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDiscard.afterDiscardCounter)
}

// DiscardBeforeCounter returns a count of TxMock.Discard invocations
func (mmDiscard *TxMock) DiscardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDiscard.beforeDiscardCounter)
}

// MinimockDiscardDone returns true if the count of the Discard invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockDiscardDone() bool {
	for _, e := range m.DiscardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DiscardMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDiscardCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDiscard != nil && mm_atomic.LoadUint64(&m.afterDiscardCounter) < 1 {
		return false
	}
	return true
}

// MinimockDiscardInspect logs each unmet expectation
func (m *TxMock) MinimockDiscardInspect() {
	for _, e := range m.DiscardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.Discard")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DiscardMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDiscardCounter) < 1 {
		m.t.Error("Expected call to TxMock.Discard")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDiscard != nil && mm_atomic.LoadUint64(&m.afterDiscardCounter) < 1 {
		m.t.Error("Expected call to TxMock.Discard")
	}
}

type mTxMockGetByPrefix struct {
	mock               *TxMock
	defaultExpectation *TxMockGetByPrefixExpectation
	expectations       []*TxMockGetByPrefixExpectation

	callArgs []*TxMockGetByPrefixParams
	mutex    sync.RWMutex
}

// TxMockGetByPrefixExpectation specifies expectation struct of the Tx.GetByPrefix
type TxMockGetByPrefixExpectation struct {
	mock    *TxMock
	params  *TxMockGetByPrefixParams
	results *TxMockGetByPrefixResults
	Counter uint64
}

// TxMockGetByPrefixParams contains parameters of the Tx.GetByPrefix
type TxMockGetByPrefixParams struct {
	ba1 []byte
}

// TxMockGetByPrefixResults contains results of the Tx.GetByPrefix
type TxMockGetByPrefixResults struct {
	result []*mm_elldb.KVObject
}

// Expect sets up expected params for Tx.GetByPrefix
func (mmGetByPrefix *mTxMockGetByPrefix) Expect(ba1 []byte) *mTxMockGetByPrefix {
	if mmGetByPrefix.mock.funcGetByPrefix != nil {
		mmGetByPrefix.mock.t.Fatalf("TxMock.GetByPrefix mock is already set by Set")
	}

	if mmGetByPrefix.defaultExpectation == nil {
		mmGetByPrefix.defaultExpectation = &TxMockGetByPrefixExpectation{}
	}

	mmGetByPrefix.defaultExpectation.params = &TxMockGetByPrefixParams{ba1}
	for _, e := range mmGetByPrefix.expectations {
		if minimock.Equal(e.params, mmGetByPrefix.defaultExpectation.params) {
			mmGetByPrefix.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByPrefix.defaultExpectation.params)
		}
	}

	return mmGetByPrefix
}

// Inspect accepts an inspector function that has same arguments as the Tx.GetByPrefix
func (mmGetByPrefix *mTxMockGetByPrefix) Inspect(f func(ba1 []byte)) *mTxMockGetByPrefix {
	if mmGetByPrefix.mock.inspectFuncGetByPrefix != nil {
		mmGetByPrefix.mock.t.Fatalf("Inspect function is already set for TxMock.GetByPrefix")
	}

	mmGetByPrefix.mock.inspectFuncGetByPrefix = f

	return mmGetByPrefix
}

// Return sets up results that will be returned by Tx.GetByPrefix
func (mmGetByPrefix *mTxMockGetByPrefix) Return(result []*mm_elldb.KVObject) *TxMock {
	if mmGetByPrefix.mock.funcGetByPrefix != nil {
		mmGetByPrefix.mock.t.Fatalf("TxMock.GetByPrefix mock is already set by Set")
	}

	if mmGetByPrefix.defaultExpectation == nil {
		mmGetByPrefix.defaultExpectation = &TxMockGetByPrefixExpectation{mock: mmGetByPrefix.mock}
	}
	mmGetByPrefix.defaultExpectation.results = &TxMockGetByPrefixResults{result}
	return mmGetByPrefix.mock
}

//Set uses given function f to mock the Tx.GetByPrefix method
func (mmGetByPrefix *mTxMockGetByPrefix) Set(f func(ba1 []byte) (result []*mm_elldb.KVObject)) *TxMock {
	if mmGetByPrefix.defaultExpectation != nil {
		mmGetByPrefix.mock.t.Fatalf("Default expectation is already set for the Tx.GetByPrefix method")
	}

	if len(mmGetByPrefix.expectations) > 0 {
		mmGetByPrefix.mock.t.Fatalf("Some expectations are already set for the Tx.GetByPrefix method")
	}

	mmGetByPrefix.mock.funcGetByPrefix = f
	return mmGetByPrefix.mock
}

// When sets expectation for the Tx.GetByPrefix which will trigger the result defined by the following
// Then helper
func (mmGetByPrefix *mTxMockGetByPrefix) When(ba1 []byte) *TxMockGetByPrefixExpectation {
	if mmGetByPrefix.mock.funcGetByPrefix != nil {
		mmGetByPrefix.mock.t.Fatalf("TxMock.GetByPrefix mock is already set by Set")
	}

	expectation := &TxMockGetByPrefixExpectation{
		mock:   mmGetByPrefix.mock,
		params: &TxMockGetByPrefixParams{ba1},
	}
	mmGetByPrefix.expectations = append(mmGetByPrefix.expectations, expectation)
	return expectation
}

// Then sets up Tx.GetByPrefix return parameters for the expectation previously defined by the When method
func (e *TxMockGetByPrefixExpectation) Then(result []*mm_elldb.KVObject) *TxMock {
	e.results = &TxMockGetByPrefixResults{result}
	return e.mock
}

// GetByPrefix implements elldb.Tx
func (mmGetByPrefix *TxMock) GetByPrefix(ba1 []byte) (result []*mm_elldb.KVObject) {
	mm_atomic.AddUint64(&mmGetByPrefix.beforeGetByPrefixCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByPrefix.afterGetByPrefixCounter, 1)

	if mmGetByPrefix.inspectFuncGetByPrefix != nil {
		mmGetByPrefix.inspectFuncGetByPrefix(ba1)
	}

	mm_params := &TxMockGetByPrefixParams{ba1}

	// Record call args
	mmGetByPrefix.GetByPrefixMock.mutex.Lock()
	mmGetByPrefix.GetByPrefixMock.callArgs = append(mmGetByPrefix.GetByPrefixMock.callArgs, mm_params)
	mmGetByPrefix.GetByPrefixMock.mutex.Unlock()

	for _, e := range mmGetByPrefix.GetByPrefixMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.result
		}
	}

	if mmGetByPrefix.GetByPrefixMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByPrefix.GetByPrefixMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByPrefix.GetByPrefixMock.defaultExpectation.params
		mm_got := TxMockGetByPrefixParams{ba1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByPrefix.t.Errorf("TxMock.GetByPrefix got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByPrefix.GetByPrefixMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByPrefix.t.Fatal("No results are set for the TxMock.GetByPrefix")
		}
		return (*mm_results).result
	}
	if mmGetByPrefix.funcGetByPrefix != nil {
		return mmGetByPrefix.funcGetByPrefix(ba1)
	}
	mmGetByPrefix.t.Fatalf("Unexpected call to TxMock.GetByPrefix. %v", ba1)
	return
}

// GetByPrefixAfterCounter returns a count of finished TxMock.GetByPrefix invocations
func (mmGetByPrefix *TxMock) GetByPrefixAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByPrefix.afterGetByPrefixCounter)
}

// GetByPrefixBeforeCounter returns a count of TxMock.GetByPrefix invocations
func (mmGetByPrefix *TxMock) GetByPrefixBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByPrefix.beforeGetByPrefixCounter)
}

// Calls returns a list of arguments used in each call to TxMock.GetByPrefix.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByPrefix *mTxMockGetByPrefix) Calls() []*TxMockGetByPrefixParams {
	mmGetByPrefix.mutex.RLock()

	argCopy := make([]*TxMockGetByPrefixParams, len(mmGetByPrefix.callArgs))
	copy(argCopy, mmGetByPrefix.callArgs)

	mmGetByPrefix.mutex.RUnlock()

	return argCopy
}

// MinimockGetByPrefixDone returns true if the count of the GetByPrefix invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockGetByPrefixDone() bool {
	for _, e := range m.GetByPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByPrefixCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByPrefix != nil && mm_atomic.LoadUint64(&m.afterGetByPrefixCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByPrefixInspect logs each unmet expectation
func (m *TxMock) MinimockGetByPrefixInspect() {
	for _, e := range m.GetByPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.GetByPrefix with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByPrefixCounter) < 1 {
		if m.GetByPrefixMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.GetByPrefix")
		} else {
			m.t.Errorf("Expected call to TxMock.GetByPrefix with params: %#v", *m.GetByPrefixMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByPrefix != nil && mm_atomic.LoadUint64(&m.afterGetByPrefixCounter) < 1 {
		m.t.Error("Expected call to TxMock.GetByPrefix")
	}
}

type mTxMockIterate struct {
	mock               *TxMock
	defaultExpectation *TxMockIterateExpectation
	expectations       []*TxMockIterateExpectation

	callArgs []*TxMockIterateParams
	mutex    sync.RWMutex
}

// TxMockIterateExpectation specifies expectation struct of the Tx.Iterate
type TxMockIterateExpectation struct {
	mock   *TxMock
	params *TxMockIterateParams

	Counter uint64
}

// TxMockIterateParams contains parameters of the Tx.Iterate
type TxMockIterateParams struct {
	prefix   []byte
	first    bool
	iterFunc func(kv *mm_elldb.KVObject) bool
}

// Expect sets up expected params for Tx.Iterate
func (mmIterate *mTxMockIterate) Expect(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool) *mTxMockIterate {
	if mmIterate.mock.funcIterate != nil {
		mmIterate.mock.t.Fatalf("TxMock.Iterate mock is already set by Set")
	}

	if mmIterate.defaultExpectation == nil {
		mmIterate.defaultExpectation = &TxMockIterateExpectation{}
	}

	mmIterate.defaultExpectation.params = &TxMockIterateParams{prefix, first, iterFunc}
	for _, e := range mmIterate.expectations {
		if minimock.Equal(e.params, mmIterate.defaultExpectation.params) {
			mmIterate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIterate.defaultExpectation.params)
		}
	}

	return mmIterate
}

// Inspect accepts an inspector function that has same arguments as the Tx.Iterate
func (mmIterate *mTxMockIterate) Inspect(f func(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool)) *mTxMockIterate {
	if mmIterate.mock.inspectFuncIterate != nil {
		mmIterate.mock.t.Fatalf("Inspect function is already set for TxMock.Iterate")
	}

	mmIterate.mock.inspectFuncIterate = f

	return mmIterate
}

// Return sets up results that will be returned by Tx.Iterate
func (mmIterate *mTxMockIterate) Return() *TxMock {
	if mmIterate.mock.funcIterate != nil {
		mmIterate.mock.t.Fatalf("TxMock.Iterate mock is already set by Set")
	}

	if mmIterate.defaultExpectation == nil {
		mmIterate.defaultExpectation = &TxMockIterateExpectation{mock: mmIterate.mock}
	}

	return mmIterate.mock
}

//Set uses given function f to mock the Tx.Iterate method
func (mmIterate *mTxMockIterate) Set(f func(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool)) *TxMock {
	if mmIterate.defaultExpectation != nil {
		mmIterate.mock.t.Fatalf("Default expectation is already set for the Tx.Iterate method")
	}

	if len(mmIterate.expectations) > 0 {
		mmIterate.mock.t.Fatalf("Some expectations are already set for the Tx.Iterate method")
	}

	mmIterate.mock.funcIterate = f
	return mmIterate.mock
}

// Iterate implements elldb.Tx
func (mmIterate *TxMock) Iterate(prefix []byte, first bool, iterFunc func(kv *mm_elldb.KVObject) bool) {
	mm_atomic.AddUint64(&mmIterate.beforeIterateCounter, 1)
	defer mm_atomic.AddUint64(&mmIterate.afterIterateCounter, 1)

	if mmIterate.inspectFuncIterate != nil {
		mmIterate.inspectFuncIterate(prefix, first, iterFunc)
	}

	mm_params := &TxMockIterateParams{prefix, first, iterFunc}

	// Record call args
	mmIterate.IterateMock.mutex.Lock()
	mmIterate.IterateMock.callArgs = append(mmIterate.IterateMock.callArgs, mm_params)
	mmIterate.IterateMock.mutex.Unlock()

	for _, e := range mmIterate.IterateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmIterate.IterateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIterate.IterateMock.defaultExpectation.Counter, 1)
		mm_want := mmIterate.IterateMock.defaultExpectation.params
		mm_got := TxMockIterateParams{prefix, first, iterFunc}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIterate.t.Errorf("TxMock.Iterate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmIterate.funcIterate != nil {
		mmIterate.funcIterate(prefix, first, iterFunc)
		return
	}
	mmIterate.t.Fatalf("Unexpected call to TxMock.Iterate. %v %v %v", prefix, first, iterFunc)

}

// IterateAfterCounter returns a count of finished TxMock.Iterate invocations
func (mmIterate *TxMock) IterateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIterate.afterIterateCounter)
}

// IterateBeforeCounter returns a count of TxMock.Iterate invocations
func (mmIterate *TxMock) IterateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIterate.beforeIterateCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Iterate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIterate *mTxMockIterate) Calls() []*TxMockIterateParams {
	mmIterate.mutex.RLock()

	argCopy := make([]*TxMockIterateParams, len(mmIterate.callArgs))
	copy(argCopy, mmIterate.callArgs)

	mmIterate.mutex.RUnlock()

	return argCopy
}

// MinimockIterateDone returns true if the count of the Iterate invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockIterateDone() bool {
	for _, e := range m.IterateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IterateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIterateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIterate != nil && mm_atomic.LoadUint64(&m.afterIterateCounter) < 1 {
		return false
	}
	return true
}

// MinimockIterateInspect logs each unmet expectation
func (m *TxMock) MinimockIterateInspect() {
	for _, e := range m.IterateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Iterate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IterateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIterateCounter) < 1 {
		if m.IterateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Iterate")
		} else {
			m.t.Errorf("Expected call to TxMock.Iterate with params: %#v", *m.IterateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIterate != nil && mm_atomic.LoadUint64(&m.afterIterateCounter) < 1 {
		m.t.Error("Expected call to TxMock.Iterate")
	}
}

type mTxMockPut struct {
	mock               *TxMock
	defaultExpectation *TxMockPutExpectation
	expectations       []*TxMockPutExpectation

	callArgs []*TxMockPutParams
	mutex    sync.RWMutex
}

// TxMockPutExpectation specifies expectation struct of the Tx.Put
type TxMockPutExpectation struct {
	mock    *TxMock
	params  *TxMockPutParams
	results *TxMockPutResults
	Counter uint64
}

// TxMockPutParams contains parameters of the Tx.Put
type TxMockPutParams struct {
	kpa1 []*mm_elldb.KVObject
}

// TxMockPutResults contains results of the Tx.Put
type TxMockPutResults struct {
	err error
}

// Expect sets up expected params for Tx.Put
func (mmPut *mTxMockPut) Expect(kpa1 []*mm_elldb.KVObject) *mTxMockPut {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("TxMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &TxMockPutExpectation{}
	}

	mmPut.defaultExpectation.params = &TxMockPutParams{kpa1}
	for _, e := range mmPut.expectations {
		if minimock.Equal(e.params, mmPut.defaultExpectation.params) {
			mmPut.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPut.defaultExpectation.params)
		}
	}

	return mmPut
}

// Inspect accepts an inspector function that has same arguments as the Tx.Put
func (mmPut *mTxMockPut) Inspect(f func(kpa1 []*mm_elldb.KVObject)) *mTxMockPut {
	if mmPut.mock.inspectFuncPut != nil {
		mmPut.mock.t.Fatalf("Inspect function is already set for TxMock.Put")
	}

	mmPut.mock.inspectFuncPut = f

	return mmPut
}

// Return sets up results that will be returned by Tx.Put
func (mmPut *mTxMockPut) Return(err error) *TxMock {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("TxMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &TxMockPutExpectation{mock: mmPut.mock}
	}
	mmPut.defaultExpectation.results = &TxMockPutResults{err}
	return mmPut.mock
}

//Set uses given function f to mock the Tx.Put method
func (mmPut *mTxMockPut) Set(f func(kpa1 []*mm_elldb.KVObject) (err error)) *TxMock {
	if mmPut.defaultExpectation != nil {
		mmPut.mock.t.Fatalf("Default expectation is already set for the Tx.Put method")
	}

	if len(mmPut.expectations) > 0 {
		mmPut.mock.t.Fatalf("Some expectations are already set for the Tx.Put method")
	}

	mmPut.mock.funcPut = f
	return mmPut.mock
}

// When sets expectation for the Tx.Put which will trigger the result defined by the following
// Then helper
func (mmPut *mTxMockPut) When(kpa1 []*mm_elldb.KVObject) *TxMockPutExpectation {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("TxMock.Put mock is already set by Set")
	}

	expectation := &TxMockPutExpectation{
		mock:   mmPut.mock,
		params: &TxMockPutParams{kpa1},
	}
	mmPut.expectations = append(mmPut.expectations, expectation)
	return expectation
}

// Then sets up Tx.Put return parameters for the expectation previously defined by the When method
func (e *TxMockPutExpectation) Then(err error) *TxMock {
	e.results = &TxMockPutResults{err}
	return e.mock
}

// Put implements elldb.Tx
func (mmPut *TxMock) Put(kpa1 []*mm_elldb.KVObject) (err error) {
	mm_atomic.AddUint64(&mmPut.beforePutCounter, 1)
	defer mm_atomic.AddUint64(&mmPut.afterPutCounter, 1)

	if mmPut.inspectFuncPut != nil {
		mmPut.inspectFuncPut(kpa1)
	}

	mm_params := &TxMockPutParams{kpa1}

	// Record call args
	mmPut.PutMock.mutex.Lock()
	mmPut.PutMock.callArgs = append(mmPut.PutMock.callArgs, mm_params)
	mmPut.PutMock.mutex.Unlock()

	for _, e := range mmPut.PutMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPut.PutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPut.PutMock.defaultExpectation.Counter, 1)
		mm_want := mmPut.PutMock.defaultExpectation.params
		mm_got := TxMockPutParams{kpa1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPut.t.Errorf("TxMock.Put got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPut.PutMock.defaultExpectation.results
		if mm_results == nil {
			mmPut.t.Fatal("No results are set for the TxMock.Put")
		}
		return (*mm_results).err
	}
	if mmPut.funcPut != nil {
		return mmPut.funcPut(kpa1)
	}
	mmPut.t.Fatalf("Unexpected call to TxMock.Put. %v", kpa1)
	return
}

// PutAfterCounter returns a count of finished TxMock.Put invocations
func (mmPut *TxMock) PutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.afterPutCounter)
}

// PutBeforeCounter returns a count of TxMock.Put invocations
func (mmPut *TxMock) PutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.beforePutCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Put.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPut *mTxMockPut) Calls() []*TxMockPutParams {
	mmPut.mutex.RLock()

	argCopy := make([]*TxMockPutParams, len(mmPut.callArgs))
	copy(argCopy, mmPut.callArgs)

	mmPut.mutex.RUnlock()

	return argCopy
}

// MinimockPutDone returns true if the count of the Put invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockPutDone() bool {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	return true
}

// MinimockPutInspect logs each unmet expectation
func (m *TxMock) MinimockPutInspect() {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Put with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		if m.PutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Put")
		} else {
			m.t.Errorf("Expected call to TxMock.Put with params: %#v", *m.PutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		m.t.Error("Expected call to TxMock.Put")
	}
}

type mTxMockRollback struct {
	mock               *TxMock
	defaultExpectation *TxMockRollbackExpectation
	expectations       []*TxMockRollbackExpectation
}

// TxMockRollbackExpectation specifies expectation struct of the Tx.Rollback
type TxMockRollbackExpectation struct {
	mock *TxMock

	Counter uint64
}

// Expect sets up expected params for Tx.Rollback
func (mmRollback *mTxMockRollback) Expect() *mTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{}
	}

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the Tx.Rollback
func (mmRollback *mTxMockRollback) Inspect(f func()) *mTxMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for TxMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by Tx.Rollback
func (mmRollback *mTxMockRollback) Return() *TxMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{mock: mmRollback.mock}
	}

	return mmRollback.mock
}

//Set uses given function f to mock the Tx.Rollback method
func (mmRollback *mTxMockRollback) Set(f func()) *TxMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the Tx.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the Tx.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	return mmRollback.mock
}

// Rollback implements elldb.Tx
func (mmRollback *TxMock) Rollback() {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback()
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)

		return

	}
	if mmRollback.funcRollback != nil {
		mmRollback.funcRollback()
		return
	}
	mmRollback.t.Fatalf("Unexpected call to TxMock.Rollback.")

}

// RollbackAfterCounter returns a count of finished TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockRollbackDone() bool {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockRollbackInspect logs each unmet expectation
func (m *TxMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.Rollback")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to TxMock.Rollback")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to TxMock.Rollback")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TxMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCommitInspect()

		m.MinimockDeleteByPrefixInspect()

		m.MinimockDiscardInspect()

		m.MinimockGetByPrefixInspect()

		m.MinimockIterateInspect()

		m.MinimockPutInspect()

		m.MinimockRollbackInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCommitDone() &&
		m.MinimockDeleteByPrefixDone() &&
		m.MinimockDiscardDone() &&
		m.MinimockGetByPrefixDone() &&
		m.MinimockIterateDone() &&
		m.MinimockPutDone() &&
		m.MinimockRollbackDone()
}
