package burner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/ellcrys/elld/burner.RPCClient -o ./rpc_client_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/ellcrys/ltcd/btcjson"
	"github.com/ellcrys/ltcd/chaincfg/chainhash"
	"github.com/ellcrys/ltcd/wire"
	"github.com/gojuno/minimock"
)

// RPCClientMock implements RPCClient
type RPCClientMock struct {
	t minimock.Tester

	funcGetBestBlock          func() (hp1 *chainhash.Hash, i1 int32, err error)
	inspectFuncGetBestBlock   func()
	afterGetBestBlockCounter  uint64
	beforeGetBestBlockCounter uint64
	GetBestBlockMock          mRPCClientMockGetBestBlock

	funcGetBlockHash          func(blockHeight int64) (hp1 *chainhash.Hash, err error)
	inspectFuncGetBlockHash   func(blockHeight int64)
	afterGetBlockHashCounter  uint64
	beforeGetBlockHashCounter uint64
	GetBlockHashMock          mRPCClientMockGetBlockHash

	funcGetBlockHeader          func(blockHash *chainhash.Hash) (bp1 *wire.BlockHeader, err error)
	inspectFuncGetBlockHeader   func(blockHash *chainhash.Hash)
	afterGetBlockHeaderCounter  uint64
	beforeGetBlockHeaderCounter uint64
	GetBlockHeaderMock          mRPCClientMockGetBlockHeader

	funcGetBlockVerboseTx          func(blockHash *chainhash.Hash) (gp1 *btcjson.GetBlockVerboseResult, err error)
	inspectFuncGetBlockVerboseTx   func(blockHash *chainhash.Hash)
	afterGetBlockVerboseTxCounter  uint64
	beforeGetBlockVerboseTxCounter uint64
	GetBlockVerboseTxMock          mRPCClientMockGetBlockVerboseTx
}

// NewRPCClientMock returns a mock for RPCClient
func NewRPCClientMock(t minimock.Tester) *RPCClientMock {
	m := &RPCClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetBestBlockMock = mRPCClientMockGetBestBlock{mock: m}

	m.GetBlockHashMock = mRPCClientMockGetBlockHash{mock: m}
	m.GetBlockHashMock.callArgs = []*RPCClientMockGetBlockHashParams{}

	m.GetBlockHeaderMock = mRPCClientMockGetBlockHeader{mock: m}
	m.GetBlockHeaderMock.callArgs = []*RPCClientMockGetBlockHeaderParams{}

	m.GetBlockVerboseTxMock = mRPCClientMockGetBlockVerboseTx{mock: m}
	m.GetBlockVerboseTxMock.callArgs = []*RPCClientMockGetBlockVerboseTxParams{}

	return m
}

type mRPCClientMockGetBestBlock struct {
	mock               *RPCClientMock
	defaultExpectation *RPCClientMockGetBestBlockExpectation
	expectations       []*RPCClientMockGetBestBlockExpectation
}

// RPCClientMockGetBestBlockExpectation specifies expectation struct of the RPCClient.GetBestBlock
type RPCClientMockGetBestBlockExpectation struct {
	mock *RPCClientMock

	results *RPCClientMockGetBestBlockResults
	Counter uint64
}

// RPCClientMockGetBestBlockResults contains results of the RPCClient.GetBestBlock
type RPCClientMockGetBestBlockResults struct {
	hp1 *chainhash.Hash
	i1  int32
	err error
}

// Expect sets up expected params for RPCClient.GetBestBlock
func (mmGetBestBlock *mRPCClientMockGetBestBlock) Expect() *mRPCClientMockGetBestBlock {
	if mmGetBestBlock.mock.funcGetBestBlock != nil {
		mmGetBestBlock.mock.t.Fatalf("RPCClientMock.GetBestBlock mock is already set by Set")
	}

	if mmGetBestBlock.defaultExpectation == nil {
		mmGetBestBlock.defaultExpectation = &RPCClientMockGetBestBlockExpectation{}
	}

	return mmGetBestBlock
}

// Inspect accepts an inspector function that has same arguments as the RPCClient.GetBestBlock
func (mmGetBestBlock *mRPCClientMockGetBestBlock) Inspect(f func()) *mRPCClientMockGetBestBlock {
	if mmGetBestBlock.mock.inspectFuncGetBestBlock != nil {
		mmGetBestBlock.mock.t.Fatalf("Inspect function is already set for RPCClientMock.GetBestBlock")
	}

	mmGetBestBlock.mock.inspectFuncGetBestBlock = f

	return mmGetBestBlock
}

// Return sets up results that will be returned by RPCClient.GetBestBlock
func (mmGetBestBlock *mRPCClientMockGetBestBlock) Return(hp1 *chainhash.Hash, i1 int32, err error) *RPCClientMock {
	if mmGetBestBlock.mock.funcGetBestBlock != nil {
		mmGetBestBlock.mock.t.Fatalf("RPCClientMock.GetBestBlock mock is already set by Set")
	}

	if mmGetBestBlock.defaultExpectation == nil {
		mmGetBestBlock.defaultExpectation = &RPCClientMockGetBestBlockExpectation{mock: mmGetBestBlock.mock}
	}
	mmGetBestBlock.defaultExpectation.results = &RPCClientMockGetBestBlockResults{hp1, i1, err}
	return mmGetBestBlock.mock
}

//Set uses given function f to mock the RPCClient.GetBestBlock method
func (mmGetBestBlock *mRPCClientMockGetBestBlock) Set(f func() (hp1 *chainhash.Hash, i1 int32, err error)) *RPCClientMock {
	if mmGetBestBlock.defaultExpectation != nil {
		mmGetBestBlock.mock.t.Fatalf("Default expectation is already set for the RPCClient.GetBestBlock method")
	}

	if len(mmGetBestBlock.expectations) > 0 {
		mmGetBestBlock.mock.t.Fatalf("Some expectations are already set for the RPCClient.GetBestBlock method")
	}

	mmGetBestBlock.mock.funcGetBestBlock = f
	return mmGetBestBlock.mock
}

// GetBestBlock implements RPCClient
func (mmGetBestBlock *RPCClientMock) GetBestBlock() (hp1 *chainhash.Hash, i1 int32, err error) {
	mm_atomic.AddUint64(&mmGetBestBlock.beforeGetBestBlockCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBestBlock.afterGetBestBlockCounter, 1)

	if mmGetBestBlock.inspectFuncGetBestBlock != nil {
		mmGetBestBlock.inspectFuncGetBestBlock()
	}

	if mmGetBestBlock.GetBestBlockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBestBlock.GetBestBlockMock.defaultExpectation.Counter, 1)

		mm_results := mmGetBestBlock.GetBestBlockMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBestBlock.t.Fatal("No results are set for the RPCClientMock.GetBestBlock")
		}
		return (*mm_results).hp1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetBestBlock.funcGetBestBlock != nil {
		return mmGetBestBlock.funcGetBestBlock()
	}
	mmGetBestBlock.t.Fatalf("Unexpected call to RPCClientMock.GetBestBlock.")
	return
}

// GetBestBlockAfterCounter returns a count of finished RPCClientMock.GetBestBlock invocations
func (mmGetBestBlock *RPCClientMock) GetBestBlockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBestBlock.afterGetBestBlockCounter)
}

// GetBestBlockBeforeCounter returns a count of RPCClientMock.GetBestBlock invocations
func (mmGetBestBlock *RPCClientMock) GetBestBlockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBestBlock.beforeGetBestBlockCounter)
}

// MinimockGetBestBlockDone returns true if the count of the GetBestBlock invocations corresponds
// the number of defined expectations
func (m *RPCClientMock) MinimockGetBestBlockDone() bool {
	for _, e := range m.GetBestBlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBestBlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBestBlockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBestBlock != nil && mm_atomic.LoadUint64(&m.afterGetBestBlockCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBestBlockInspect logs each unmet expectation
func (m *RPCClientMock) MinimockGetBestBlockInspect() {
	for _, e := range m.GetBestBlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RPCClientMock.GetBestBlock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBestBlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBestBlockCounter) < 1 {
		m.t.Error("Expected call to RPCClientMock.GetBestBlock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBestBlock != nil && mm_atomic.LoadUint64(&m.afterGetBestBlockCounter) < 1 {
		m.t.Error("Expected call to RPCClientMock.GetBestBlock")
	}
}

type mRPCClientMockGetBlockHash struct {
	mock               *RPCClientMock
	defaultExpectation *RPCClientMockGetBlockHashExpectation
	expectations       []*RPCClientMockGetBlockHashExpectation

	callArgs []*RPCClientMockGetBlockHashParams
	mutex    sync.RWMutex
}

// RPCClientMockGetBlockHashExpectation specifies expectation struct of the RPCClient.GetBlockHash
type RPCClientMockGetBlockHashExpectation struct {
	mock    *RPCClientMock
	params  *RPCClientMockGetBlockHashParams
	results *RPCClientMockGetBlockHashResults
	Counter uint64
}

// RPCClientMockGetBlockHashParams contains parameters of the RPCClient.GetBlockHash
type RPCClientMockGetBlockHashParams struct {
	blockHeight int64
}

// RPCClientMockGetBlockHashResults contains results of the RPCClient.GetBlockHash
type RPCClientMockGetBlockHashResults struct {
	hp1 *chainhash.Hash
	err error
}

// Expect sets up expected params for RPCClient.GetBlockHash
func (mmGetBlockHash *mRPCClientMockGetBlockHash) Expect(blockHeight int64) *mRPCClientMockGetBlockHash {
	if mmGetBlockHash.mock.funcGetBlockHash != nil {
		mmGetBlockHash.mock.t.Fatalf("RPCClientMock.GetBlockHash mock is already set by Set")
	}

	if mmGetBlockHash.defaultExpectation == nil {
		mmGetBlockHash.defaultExpectation = &RPCClientMockGetBlockHashExpectation{}
	}

	mmGetBlockHash.defaultExpectation.params = &RPCClientMockGetBlockHashParams{blockHeight}
	for _, e := range mmGetBlockHash.expectations {
		if minimock.Equal(e.params, mmGetBlockHash.defaultExpectation.params) {
			mmGetBlockHash.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBlockHash.defaultExpectation.params)
		}
	}

	return mmGetBlockHash
}

// Inspect accepts an inspector function that has same arguments as the RPCClient.GetBlockHash
func (mmGetBlockHash *mRPCClientMockGetBlockHash) Inspect(f func(blockHeight int64)) *mRPCClientMockGetBlockHash {
	if mmGetBlockHash.mock.inspectFuncGetBlockHash != nil {
		mmGetBlockHash.mock.t.Fatalf("Inspect function is already set for RPCClientMock.GetBlockHash")
	}

	mmGetBlockHash.mock.inspectFuncGetBlockHash = f

	return mmGetBlockHash
}

// Return sets up results that will be returned by RPCClient.GetBlockHash
func (mmGetBlockHash *mRPCClientMockGetBlockHash) Return(hp1 *chainhash.Hash, err error) *RPCClientMock {
	if mmGetBlockHash.mock.funcGetBlockHash != nil {
		mmGetBlockHash.mock.t.Fatalf("RPCClientMock.GetBlockHash mock is already set by Set")
	}

	if mmGetBlockHash.defaultExpectation == nil {
		mmGetBlockHash.defaultExpectation = &RPCClientMockGetBlockHashExpectation{mock: mmGetBlockHash.mock}
	}
	mmGetBlockHash.defaultExpectation.results = &RPCClientMockGetBlockHashResults{hp1, err}
	return mmGetBlockHash.mock
}

//Set uses given function f to mock the RPCClient.GetBlockHash method
func (mmGetBlockHash *mRPCClientMockGetBlockHash) Set(f func(blockHeight int64) (hp1 *chainhash.Hash, err error)) *RPCClientMock {
	if mmGetBlockHash.defaultExpectation != nil {
		mmGetBlockHash.mock.t.Fatalf("Default expectation is already set for the RPCClient.GetBlockHash method")
	}

	if len(mmGetBlockHash.expectations) > 0 {
		mmGetBlockHash.mock.t.Fatalf("Some expectations are already set for the RPCClient.GetBlockHash method")
	}

	mmGetBlockHash.mock.funcGetBlockHash = f
	return mmGetBlockHash.mock
}

// When sets expectation for the RPCClient.GetBlockHash which will trigger the result defined by the following
// Then helper
func (mmGetBlockHash *mRPCClientMockGetBlockHash) When(blockHeight int64) *RPCClientMockGetBlockHashExpectation {
	if mmGetBlockHash.mock.funcGetBlockHash != nil {
		mmGetBlockHash.mock.t.Fatalf("RPCClientMock.GetBlockHash mock is already set by Set")
	}

	expectation := &RPCClientMockGetBlockHashExpectation{
		mock:   mmGetBlockHash.mock,
		params: &RPCClientMockGetBlockHashParams{blockHeight},
	}
	mmGetBlockHash.expectations = append(mmGetBlockHash.expectations, expectation)
	return expectation
}

// Then sets up RPCClient.GetBlockHash return parameters for the expectation previously defined by the When method
func (e *RPCClientMockGetBlockHashExpectation) Then(hp1 *chainhash.Hash, err error) *RPCClientMock {
	e.results = &RPCClientMockGetBlockHashResults{hp1, err}
	return e.mock
}

// GetBlockHash implements RPCClient
func (mmGetBlockHash *RPCClientMock) GetBlockHash(blockHeight int64) (hp1 *chainhash.Hash, err error) {
	mm_atomic.AddUint64(&mmGetBlockHash.beforeGetBlockHashCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBlockHash.afterGetBlockHashCounter, 1)

	if mmGetBlockHash.inspectFuncGetBlockHash != nil {
		mmGetBlockHash.inspectFuncGetBlockHash(blockHeight)
	}

	mm_params := &RPCClientMockGetBlockHashParams{blockHeight}

	// Record call args
	mmGetBlockHash.GetBlockHashMock.mutex.Lock()
	mmGetBlockHash.GetBlockHashMock.callArgs = append(mmGetBlockHash.GetBlockHashMock.callArgs, mm_params)
	mmGetBlockHash.GetBlockHashMock.mutex.Unlock()

	for _, e := range mmGetBlockHash.GetBlockHashMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmGetBlockHash.GetBlockHashMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBlockHash.GetBlockHashMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBlockHash.GetBlockHashMock.defaultExpectation.params
		mm_got := RPCClientMockGetBlockHashParams{blockHeight}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBlockHash.t.Errorf("RPCClientMock.GetBlockHash got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBlockHash.GetBlockHashMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBlockHash.t.Fatal("No results are set for the RPCClientMock.GetBlockHash")
		}
		return (*mm_results).hp1, (*mm_results).err
	}
	if mmGetBlockHash.funcGetBlockHash != nil {
		return mmGetBlockHash.funcGetBlockHash(blockHeight)
	}
	mmGetBlockHash.t.Fatalf("Unexpected call to RPCClientMock.GetBlockHash. %v", blockHeight)
	return
}

// GetBlockHashAfterCounter returns a count of finished RPCClientMock.GetBlockHash invocations
func (mmGetBlockHash *RPCClientMock) GetBlockHashAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBlockHash.afterGetBlockHashCounter)
}

// GetBlockHashBeforeCounter returns a count of RPCClientMock.GetBlockHash invocations
func (mmGetBlockHash *RPCClientMock) GetBlockHashBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBlockHash.beforeGetBlockHashCounter)
}

// Calls returns a list of arguments used in each call to RPCClientMock.GetBlockHash.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBlockHash *mRPCClientMockGetBlockHash) Calls() []*RPCClientMockGetBlockHashParams {
	mmGetBlockHash.mutex.RLock()

	argCopy := make([]*RPCClientMockGetBlockHashParams, len(mmGetBlockHash.callArgs))
	copy(argCopy, mmGetBlockHash.callArgs)

	mmGetBlockHash.mutex.RUnlock()

	return argCopy
}

// MinimockGetBlockHashDone returns true if the count of the GetBlockHash invocations corresponds
// the number of defined expectations
func (m *RPCClientMock) MinimockGetBlockHashDone() bool {
	for _, e := range m.GetBlockHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBlockHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBlockHashCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBlockHash != nil && mm_atomic.LoadUint64(&m.afterGetBlockHashCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBlockHashInspect logs each unmet expectation
func (m *RPCClientMock) MinimockGetBlockHashInspect() {
	for _, e := range m.GetBlockHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCClientMock.GetBlockHash with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBlockHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBlockHashCounter) < 1 {
		if m.GetBlockHashMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCClientMock.GetBlockHash")
		} else {
			m.t.Errorf("Expected call to RPCClientMock.GetBlockHash with params: %#v", *m.GetBlockHashMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBlockHash != nil && mm_atomic.LoadUint64(&m.afterGetBlockHashCounter) < 1 {
		m.t.Error("Expected call to RPCClientMock.GetBlockHash")
	}
}

type mRPCClientMockGetBlockHeader struct {
	mock               *RPCClientMock
	defaultExpectation *RPCClientMockGetBlockHeaderExpectation
	expectations       []*RPCClientMockGetBlockHeaderExpectation

	callArgs []*RPCClientMockGetBlockHeaderParams
	mutex    sync.RWMutex
}

// RPCClientMockGetBlockHeaderExpectation specifies expectation struct of the RPCClient.GetBlockHeader
type RPCClientMockGetBlockHeaderExpectation struct {
	mock    *RPCClientMock
	params  *RPCClientMockGetBlockHeaderParams
	results *RPCClientMockGetBlockHeaderResults
	Counter uint64
}

// RPCClientMockGetBlockHeaderParams contains parameters of the RPCClient.GetBlockHeader
type RPCClientMockGetBlockHeaderParams struct {
	blockHash *chainhash.Hash
}

// RPCClientMockGetBlockHeaderResults contains results of the RPCClient.GetBlockHeader
type RPCClientMockGetBlockHeaderResults struct {
	bp1 *wire.BlockHeader
	err error
}

// Expect sets up expected params for RPCClient.GetBlockHeader
func (mmGetBlockHeader *mRPCClientMockGetBlockHeader) Expect(blockHash *chainhash.Hash) *mRPCClientMockGetBlockHeader {
	if mmGetBlockHeader.mock.funcGetBlockHeader != nil {
		mmGetBlockHeader.mock.t.Fatalf("RPCClientMock.GetBlockHeader mock is already set by Set")
	}

	if mmGetBlockHeader.defaultExpectation == nil {
		mmGetBlockHeader.defaultExpectation = &RPCClientMockGetBlockHeaderExpectation{}
	}

	mmGetBlockHeader.defaultExpectation.params = &RPCClientMockGetBlockHeaderParams{blockHash}
	for _, e := range mmGetBlockHeader.expectations {
		if minimock.Equal(e.params, mmGetBlockHeader.defaultExpectation.params) {
			mmGetBlockHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBlockHeader.defaultExpectation.params)
		}
	}

	return mmGetBlockHeader
}

// Inspect accepts an inspector function that has same arguments as the RPCClient.GetBlockHeader
func (mmGetBlockHeader *mRPCClientMockGetBlockHeader) Inspect(f func(blockHash *chainhash.Hash)) *mRPCClientMockGetBlockHeader {
	if mmGetBlockHeader.mock.inspectFuncGetBlockHeader != nil {
		mmGetBlockHeader.mock.t.Fatalf("Inspect function is already set for RPCClientMock.GetBlockHeader")
	}

	mmGetBlockHeader.mock.inspectFuncGetBlockHeader = f

	return mmGetBlockHeader
}

// Return sets up results that will be returned by RPCClient.GetBlockHeader
func (mmGetBlockHeader *mRPCClientMockGetBlockHeader) Return(bp1 *wire.BlockHeader, err error) *RPCClientMock {
	if mmGetBlockHeader.mock.funcGetBlockHeader != nil {
		mmGetBlockHeader.mock.t.Fatalf("RPCClientMock.GetBlockHeader mock is already set by Set")
	}

	if mmGetBlockHeader.defaultExpectation == nil {
		mmGetBlockHeader.defaultExpectation = &RPCClientMockGetBlockHeaderExpectation{mock: mmGetBlockHeader.mock}
	}
	mmGetBlockHeader.defaultExpectation.results = &RPCClientMockGetBlockHeaderResults{bp1, err}
	return mmGetBlockHeader.mock
}

//Set uses given function f to mock the RPCClient.GetBlockHeader method
func (mmGetBlockHeader *mRPCClientMockGetBlockHeader) Set(f func(blockHash *chainhash.Hash) (bp1 *wire.BlockHeader, err error)) *RPCClientMock {
	if mmGetBlockHeader.defaultExpectation != nil {
		mmGetBlockHeader.mock.t.Fatalf("Default expectation is already set for the RPCClient.GetBlockHeader method")
	}

	if len(mmGetBlockHeader.expectations) > 0 {
		mmGetBlockHeader.mock.t.Fatalf("Some expectations are already set for the RPCClient.GetBlockHeader method")
	}

	mmGetBlockHeader.mock.funcGetBlockHeader = f
	return mmGetBlockHeader.mock
}

// When sets expectation for the RPCClient.GetBlockHeader which will trigger the result defined by the following
// Then helper
func (mmGetBlockHeader *mRPCClientMockGetBlockHeader) When(blockHash *chainhash.Hash) *RPCClientMockGetBlockHeaderExpectation {
	if mmGetBlockHeader.mock.funcGetBlockHeader != nil {
		mmGetBlockHeader.mock.t.Fatalf("RPCClientMock.GetBlockHeader mock is already set by Set")
	}

	expectation := &RPCClientMockGetBlockHeaderExpectation{
		mock:   mmGetBlockHeader.mock,
		params: &RPCClientMockGetBlockHeaderParams{blockHash},
	}
	mmGetBlockHeader.expectations = append(mmGetBlockHeader.expectations, expectation)
	return expectation
}

// Then sets up RPCClient.GetBlockHeader return parameters for the expectation previously defined by the When method
func (e *RPCClientMockGetBlockHeaderExpectation) Then(bp1 *wire.BlockHeader, err error) *RPCClientMock {
	e.results = &RPCClientMockGetBlockHeaderResults{bp1, err}
	return e.mock
}

// GetBlockHeader implements RPCClient
func (mmGetBlockHeader *RPCClientMock) GetBlockHeader(blockHash *chainhash.Hash) (bp1 *wire.BlockHeader, err error) {
	mm_atomic.AddUint64(&mmGetBlockHeader.beforeGetBlockHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBlockHeader.afterGetBlockHeaderCounter, 1)

	if mmGetBlockHeader.inspectFuncGetBlockHeader != nil {
		mmGetBlockHeader.inspectFuncGetBlockHeader(blockHash)
	}

	mm_params := &RPCClientMockGetBlockHeaderParams{blockHash}

	// Record call args
	mmGetBlockHeader.GetBlockHeaderMock.mutex.Lock()
	mmGetBlockHeader.GetBlockHeaderMock.callArgs = append(mmGetBlockHeader.GetBlockHeaderMock.callArgs, mm_params)
	mmGetBlockHeader.GetBlockHeaderMock.mutex.Unlock()

	for _, e := range mmGetBlockHeader.GetBlockHeaderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGetBlockHeader.GetBlockHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBlockHeader.GetBlockHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBlockHeader.GetBlockHeaderMock.defaultExpectation.params
		mm_got := RPCClientMockGetBlockHeaderParams{blockHash}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBlockHeader.t.Errorf("RPCClientMock.GetBlockHeader got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBlockHeader.GetBlockHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBlockHeader.t.Fatal("No results are set for the RPCClientMock.GetBlockHeader")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGetBlockHeader.funcGetBlockHeader != nil {
		return mmGetBlockHeader.funcGetBlockHeader(blockHash)
	}
	mmGetBlockHeader.t.Fatalf("Unexpected call to RPCClientMock.GetBlockHeader. %v", blockHash)
	return
}

// GetBlockHeaderAfterCounter returns a count of finished RPCClientMock.GetBlockHeader invocations
func (mmGetBlockHeader *RPCClientMock) GetBlockHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBlockHeader.afterGetBlockHeaderCounter)
}

// GetBlockHeaderBeforeCounter returns a count of RPCClientMock.GetBlockHeader invocations
func (mmGetBlockHeader *RPCClientMock) GetBlockHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBlockHeader.beforeGetBlockHeaderCounter)
}

// Calls returns a list of arguments used in each call to RPCClientMock.GetBlockHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBlockHeader *mRPCClientMockGetBlockHeader) Calls() []*RPCClientMockGetBlockHeaderParams {
	mmGetBlockHeader.mutex.RLock()

	argCopy := make([]*RPCClientMockGetBlockHeaderParams, len(mmGetBlockHeader.callArgs))
	copy(argCopy, mmGetBlockHeader.callArgs)

	mmGetBlockHeader.mutex.RUnlock()

	return argCopy
}

// MinimockGetBlockHeaderDone returns true if the count of the GetBlockHeader invocations corresponds
// the number of defined expectations
func (m *RPCClientMock) MinimockGetBlockHeaderDone() bool {
	for _, e := range m.GetBlockHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBlockHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBlockHeaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBlockHeader != nil && mm_atomic.LoadUint64(&m.afterGetBlockHeaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBlockHeaderInspect logs each unmet expectation
func (m *RPCClientMock) MinimockGetBlockHeaderInspect() {
	for _, e := range m.GetBlockHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCClientMock.GetBlockHeader with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBlockHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBlockHeaderCounter) < 1 {
		if m.GetBlockHeaderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCClientMock.GetBlockHeader")
		} else {
			m.t.Errorf("Expected call to RPCClientMock.GetBlockHeader with params: %#v", *m.GetBlockHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBlockHeader != nil && mm_atomic.LoadUint64(&m.afterGetBlockHeaderCounter) < 1 {
		m.t.Error("Expected call to RPCClientMock.GetBlockHeader")
	}
}

type mRPCClientMockGetBlockVerboseTx struct {
	mock               *RPCClientMock
	defaultExpectation *RPCClientMockGetBlockVerboseTxExpectation
	expectations       []*RPCClientMockGetBlockVerboseTxExpectation

	callArgs []*RPCClientMockGetBlockVerboseTxParams
	mutex    sync.RWMutex
}

// RPCClientMockGetBlockVerboseTxExpectation specifies expectation struct of the RPCClient.GetBlockVerboseTx
type RPCClientMockGetBlockVerboseTxExpectation struct {
	mock    *RPCClientMock
	params  *RPCClientMockGetBlockVerboseTxParams
	results *RPCClientMockGetBlockVerboseTxResults
	Counter uint64
}

// RPCClientMockGetBlockVerboseTxParams contains parameters of the RPCClient.GetBlockVerboseTx
type RPCClientMockGetBlockVerboseTxParams struct {
	blockHash *chainhash.Hash
}

// RPCClientMockGetBlockVerboseTxResults contains results of the RPCClient.GetBlockVerboseTx
type RPCClientMockGetBlockVerboseTxResults struct {
	gp1 *btcjson.GetBlockVerboseResult
	err error
}

// Expect sets up expected params for RPCClient.GetBlockVerboseTx
func (mmGetBlockVerboseTx *mRPCClientMockGetBlockVerboseTx) Expect(blockHash *chainhash.Hash) *mRPCClientMockGetBlockVerboseTx {
	if mmGetBlockVerboseTx.mock.funcGetBlockVerboseTx != nil {
		mmGetBlockVerboseTx.mock.t.Fatalf("RPCClientMock.GetBlockVerboseTx mock is already set by Set")
	}

	if mmGetBlockVerboseTx.defaultExpectation == nil {
		mmGetBlockVerboseTx.defaultExpectation = &RPCClientMockGetBlockVerboseTxExpectation{}
	}

	mmGetBlockVerboseTx.defaultExpectation.params = &RPCClientMockGetBlockVerboseTxParams{blockHash}
	for _, e := range mmGetBlockVerboseTx.expectations {
		if minimock.Equal(e.params, mmGetBlockVerboseTx.defaultExpectation.params) {
			mmGetBlockVerboseTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBlockVerboseTx.defaultExpectation.params)
		}
	}

	return mmGetBlockVerboseTx
}

// Inspect accepts an inspector function that has same arguments as the RPCClient.GetBlockVerboseTx
func (mmGetBlockVerboseTx *mRPCClientMockGetBlockVerboseTx) Inspect(f func(blockHash *chainhash.Hash)) *mRPCClientMockGetBlockVerboseTx {
	if mmGetBlockVerboseTx.mock.inspectFuncGetBlockVerboseTx != nil {
		mmGetBlockVerboseTx.mock.t.Fatalf("Inspect function is already set for RPCClientMock.GetBlockVerboseTx")
	}

	mmGetBlockVerboseTx.mock.inspectFuncGetBlockVerboseTx = f

	return mmGetBlockVerboseTx
}

// Return sets up results that will be returned by RPCClient.GetBlockVerboseTx
func (mmGetBlockVerboseTx *mRPCClientMockGetBlockVerboseTx) Return(gp1 *btcjson.GetBlockVerboseResult, err error) *RPCClientMock {
	if mmGetBlockVerboseTx.mock.funcGetBlockVerboseTx != nil {
		mmGetBlockVerboseTx.mock.t.Fatalf("RPCClientMock.GetBlockVerboseTx mock is already set by Set")
	}

	if mmGetBlockVerboseTx.defaultExpectation == nil {
		mmGetBlockVerboseTx.defaultExpectation = &RPCClientMockGetBlockVerboseTxExpectation{mock: mmGetBlockVerboseTx.mock}
	}
	mmGetBlockVerboseTx.defaultExpectation.results = &RPCClientMockGetBlockVerboseTxResults{gp1, err}
	return mmGetBlockVerboseTx.mock
}

//Set uses given function f to mock the RPCClient.GetBlockVerboseTx method
func (mmGetBlockVerboseTx *mRPCClientMockGetBlockVerboseTx) Set(f func(blockHash *chainhash.Hash) (gp1 *btcjson.GetBlockVerboseResult, err error)) *RPCClientMock {
	if mmGetBlockVerboseTx.defaultExpectation != nil {
		mmGetBlockVerboseTx.mock.t.Fatalf("Default expectation is already set for the RPCClient.GetBlockVerboseTx method")
	}

	if len(mmGetBlockVerboseTx.expectations) > 0 {
		mmGetBlockVerboseTx.mock.t.Fatalf("Some expectations are already set for the RPCClient.GetBlockVerboseTx method")
	}

	mmGetBlockVerboseTx.mock.funcGetBlockVerboseTx = f
	return mmGetBlockVerboseTx.mock
}

// When sets expectation for the RPCClient.GetBlockVerboseTx which will trigger the result defined by the following
// Then helper
func (mmGetBlockVerboseTx *mRPCClientMockGetBlockVerboseTx) When(blockHash *chainhash.Hash) *RPCClientMockGetBlockVerboseTxExpectation {
	if mmGetBlockVerboseTx.mock.funcGetBlockVerboseTx != nil {
		mmGetBlockVerboseTx.mock.t.Fatalf("RPCClientMock.GetBlockVerboseTx mock is already set by Set")
	}

	expectation := &RPCClientMockGetBlockVerboseTxExpectation{
		mock:   mmGetBlockVerboseTx.mock,
		params: &RPCClientMockGetBlockVerboseTxParams{blockHash},
	}
	mmGetBlockVerboseTx.expectations = append(mmGetBlockVerboseTx.expectations, expectation)
	return expectation
}

// Then sets up RPCClient.GetBlockVerboseTx return parameters for the expectation previously defined by the When method
func (e *RPCClientMockGetBlockVerboseTxExpectation) Then(gp1 *btcjson.GetBlockVerboseResult, err error) *RPCClientMock {
	e.results = &RPCClientMockGetBlockVerboseTxResults{gp1, err}
	return e.mock
}

// GetBlockVerboseTx implements RPCClient
func (mmGetBlockVerboseTx *RPCClientMock) GetBlockVerboseTx(blockHash *chainhash.Hash) (gp1 *btcjson.GetBlockVerboseResult, err error) {
	mm_atomic.AddUint64(&mmGetBlockVerboseTx.beforeGetBlockVerboseTxCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBlockVerboseTx.afterGetBlockVerboseTxCounter, 1)

	if mmGetBlockVerboseTx.inspectFuncGetBlockVerboseTx != nil {
		mmGetBlockVerboseTx.inspectFuncGetBlockVerboseTx(blockHash)
	}

	mm_params := &RPCClientMockGetBlockVerboseTxParams{blockHash}

	// Record call args
	mmGetBlockVerboseTx.GetBlockVerboseTxMock.mutex.Lock()
	mmGetBlockVerboseTx.GetBlockVerboseTxMock.callArgs = append(mmGetBlockVerboseTx.GetBlockVerboseTxMock.callArgs, mm_params)
	mmGetBlockVerboseTx.GetBlockVerboseTxMock.mutex.Unlock()

	for _, e := range mmGetBlockVerboseTx.GetBlockVerboseTxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetBlockVerboseTx.GetBlockVerboseTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBlockVerboseTx.GetBlockVerboseTxMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBlockVerboseTx.GetBlockVerboseTxMock.defaultExpectation.params
		mm_got := RPCClientMockGetBlockVerboseTxParams{blockHash}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBlockVerboseTx.t.Errorf("RPCClientMock.GetBlockVerboseTx got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBlockVerboseTx.GetBlockVerboseTxMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBlockVerboseTx.t.Fatal("No results are set for the RPCClientMock.GetBlockVerboseTx")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetBlockVerboseTx.funcGetBlockVerboseTx != nil {
		return mmGetBlockVerboseTx.funcGetBlockVerboseTx(blockHash)
	}
	mmGetBlockVerboseTx.t.Fatalf("Unexpected call to RPCClientMock.GetBlockVerboseTx. %v", blockHash)
	return
}

// GetBlockVerboseTxAfterCounter returns a count of finished RPCClientMock.GetBlockVerboseTx invocations
func (mmGetBlockVerboseTx *RPCClientMock) GetBlockVerboseTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBlockVerboseTx.afterGetBlockVerboseTxCounter)
}

// GetBlockVerboseTxBeforeCounter returns a count of RPCClientMock.GetBlockVerboseTx invocations
func (mmGetBlockVerboseTx *RPCClientMock) GetBlockVerboseTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBlockVerboseTx.beforeGetBlockVerboseTxCounter)
}

// Calls returns a list of arguments used in each call to RPCClientMock.GetBlockVerboseTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBlockVerboseTx *mRPCClientMockGetBlockVerboseTx) Calls() []*RPCClientMockGetBlockVerboseTxParams {
	mmGetBlockVerboseTx.mutex.RLock()

	argCopy := make([]*RPCClientMockGetBlockVerboseTxParams, len(mmGetBlockVerboseTx.callArgs))
	copy(argCopy, mmGetBlockVerboseTx.callArgs)

	mmGetBlockVerboseTx.mutex.RUnlock()

	return argCopy
}

// MinimockGetBlockVerboseTxDone returns true if the count of the GetBlockVerboseTx invocations corresponds
// the number of defined expectations
func (m *RPCClientMock) MinimockGetBlockVerboseTxDone() bool {
	for _, e := range m.GetBlockVerboseTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBlockVerboseTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBlockVerboseTxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBlockVerboseTx != nil && mm_atomic.LoadUint64(&m.afterGetBlockVerboseTxCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBlockVerboseTxInspect logs each unmet expectation
func (m *RPCClientMock) MinimockGetBlockVerboseTxInspect() {
	for _, e := range m.GetBlockVerboseTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCClientMock.GetBlockVerboseTx with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBlockVerboseTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBlockVerboseTxCounter) < 1 {
		if m.GetBlockVerboseTxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCClientMock.GetBlockVerboseTx")
		} else {
			m.t.Errorf("Expected call to RPCClientMock.GetBlockVerboseTx with params: %#v", *m.GetBlockVerboseTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBlockVerboseTx != nil && mm_atomic.LoadUint64(&m.afterGetBlockVerboseTxCounter) < 1 {
		m.t.Error("Expected call to RPCClientMock.GetBlockVerboseTx")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RPCClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetBestBlockInspect()

		m.MinimockGetBlockHashInspect()

		m.MinimockGetBlockHeaderInspect()

		m.MinimockGetBlockVerboseTxInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RPCClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RPCClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetBestBlockDone() &&
		m.MinimockGetBlockHashDone() &&
		m.MinimockGetBlockHeaderDone() &&
		m.MinimockGetBlockVerboseTxDone()
}
